<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/2.4ac699a3d6a5be115d81.css">@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:400;src:url(/static/merriweather-400-l-8796b7875d52e9cb9b280211e8d3f82d.woff2) format("woff2");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}@font-face{font-display:swap;font-family:Montserrat;font-style:normal;font-weight:900;src:url(/static/montserrat-900-l-5751237264c0468be0d48ad1cea75b90.woff2) format("woff2");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}body{--pink:#ffa7c4;background-color:var(--bg)}body.light{--bg:#fff;--header:var(--pink);--textNormal:#222;--textTitle:#222;--textLink:#d23669;--hr:rgba(0,0,0,0.2);--inlineCode-bg:rgba(255,229,100,0.2);--inlineCode-text:#1a1a1a}body.dark{-webkit-font-smoothing:antialiased;--bg:#282c35;--header:#fff;--textNormal:hsla(0,0%,100%,0.88);--textTitle:#fff;--textLink:var(--pink);--hr:hsla(0,0%,100%,0.2);--inlineCode-bg:#373c49;--inlineCode-text:#e6e6e6}body:lang(ar) article,body:lang(fa) article{direction:rtl}body:lang(ar) .language-text,body:lang(ar) article .translations,body:lang(ar) article pre,body:lang(fa) .language-text,body:lang(fa) article .translations,body:lang(fa) article pre{direction:ltr}body:lang(ar) .language-text,body:lang(fa) .language-text{display:inline-block}body:lang(ar) blockquote,body:lang(fa) blockquote{border-left:unset;border-right:.32813rem solid rgba(0,0,0,.9);padding-right:1.42188rem;padding-left:unset;margin-left:.75rem;margin-right:-1.75rem}body:lang(fa) article,body:lang(fa) header>h1{font-family:Vazir}body:lang(ar) article,body:lang(ar) header>h1{font-family:Cairo,sans-serif}body:lang(ko) article,body:lang(ko) header{word-break:keep-all}code[class*=language-],pre[class*=language-]{color:#fff;background:none;font-family:Consolas,Menlo,Monaco,source-code-pro,Courier New,monospace;-webkit-font-feature-settings:normal;font-feature-settings:normal;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;margin-bottom:0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{overflow:auto;padding:1.3125rem}pre[class*=language-]::selection{background:#27292a}pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:hsla(0,0%,100%,.15)}:not(pre)>code[class*=language-]{border-radius:.3em;background:var(--inlineCode-bg);color:var(--inlineCode-text);padding:.15em .2em .05em;white-space:normal}.token.attr-name{color:#addb67;font-style:italic}.token.comment{color:#809393}.token.string,.token.url{color:#addb67}.token.variable{color:#d6deeb}.token.number{color:#f78c6c}.token.builtin,.token.char,.token.constant,.token.function{color:#82aaff}.token.punctuation{color:#c792ea}.token.doctype,.token.selector{color:#c792ea;font-style:"italic"}.token.class-name{color:#ffcb8b}.token.keyword,.token.operator,.token.tag{color:#ffa7c4}.token.boolean{color:#ff5874}.token.property{color:#80cbc4}.token.namespace{color:#b2ccd6}pre[data-line]{padding:1em 0 1em 3em;position:relative}.gatsby-highlight-code-line{background-color:#022a4b;display:block;padding-right:1em;padding-left:1.25em;border-left:.25em solid #ffa7c4}.gatsby-highlight,.gatsby-highlight-code-line{margin-right:-1.3125rem;margin-left:-1.3125rem}.gatsby-highlight{margin-bottom:1.75rem;border-radius:10px;background:#011627;-webkit-overflow-scrolling:touch;overflow:auto}@media (max-width:672px){.gatsby-highlight{border-radius:0}}.gatsby-highlight pre[class*=language-]{float:left;min-width:100%}.react-toggle{touch-action:pan-x;display:inline-block;position:relative;cursor:pointer;background-color:transparent;border:0;padding:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-tap-highlight-color:transparent}.react-toggle-screenreader-only{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.react-toggle-track{width:50px;height:24px;padding:0;border-radius:30px;background-color:#0f1114;transition:all .2s ease}.react-toggle-track-check{position:absolute;width:17px;height:17px;left:5px;top:0;bottom:0;margin-top:auto;margin-bottom:auto;line-height:0;opacity:0;transition:opacity .25s ease}.react-toggle--checked .react-toggle-track-check,.react-toggle-track-x{opacity:1;transition:opacity .25s ease}.react-toggle-track-x{position:absolute;width:17px;height:17px;right:5px;top:0;bottom:0;margin-top:auto;margin-bottom:auto;line-height:0}.react-toggle--checked .react-toggle-track-x{opacity:0}.react-toggle-thumb{position:absolute;top:1px;left:1px;width:22px;height:22px;border-radius:50%;background-color:#fafafa;box-sizing:border-box;transition:all .5s cubic-bezier(.23,1,.32,1) 0ms;-webkit-transform:translateX(0);transform:translateX(0)}.react-toggle--checked .react-toggle-thumb{-webkit-transform:translateX(26px);transform:translateX(26px);border-color:#19ab27}.react-toggle--focus .react-toggle-thumb{box-shadow:0 0 2px 3px #ffa7c4}.react-toggle:active .react-toggle-thumb{box-shadow:0 0 5px 5px #ffa7c4}</style><style data-href="/component---src-templates-blog-post-js.f3aea2f29a9b96501823.css">@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:400;src:url(/static/merriweather-400-i-l-9a3ea56a5f449980432ace5972181ef6.woff2) format("woff2");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}@font-face{font-display:swap;font-family:Merriweather;font-style:normal;font-weight:700;src:url(/static/merriweather-700-l-e24e02bb044cb07539a3a6bd12348d14.woff2) format("woff2");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}@font-face{font-display:swap;font-family:Merriweather;font-style:italic;font-weight:700;src:url(/static/merriweather-700-i-l-ad085ede31afcc5585ff34869b1cd029.woff2) format("woff2");unicode-range:U+00??,U+0131,U+0152-0153,U+02bb-02bc,U+02c6,U+02da,U+02dc,U+2000-206f,U+2074,U+20ac,U+2122,U+2191,U+2193,U+2212,U+2215,U+feff,U+fffd}.formkit-form *{box-sizing:border-box}.formkit-form legend{border:none;font-size:inherit;margin-bottom:10px;padding:0;position:relative;display:table}.formkit-form fieldset{border:0;padding:.01em 0 0;margin:0;min-width:0}.formkit-form body:not(:-moz-handler-blocked) fieldset{display:table-cell}.formkit-form p{color:inherit;font-size:inherit;font-weight:inherit}.formkit-form[data-format="slide in"],.formkit-form[data-format=modal]{display:none}.formkit-form .formkit-checkboxes,.formkit-form .formkit-input,.formkit-form .formkit-select{width:100%}.formkit-form .formkit-button,.formkit-form .formkit-submit{border:0;border-radius:5px;color:#fff;cursor:pointer;display:inline-block;text-align:center;font-size:15px;font-weight:500;margin-bottom:15px;overflow:hidden;padding:0;position:relative;vertical-align:middle}.formkit-form .formkit-button:focus,.formkit-form .formkit-button:hover,.formkit-form .formkit-submit:focus,.formkit-form .formkit-submit:hover{outline:none}.formkit-form .formkit-button:focus>span,.formkit-form .formkit-button:hover>span,.formkit-form .formkit-submit:focus>span,.formkit-form .formkit-submit:hover>span{background-color:#dc658d}.formkit-form .formkit-button>span,.formkit-form .formkit-submit>span{display:block;transition:all .3s ease-in-out;padding:12px 24px}.formkit-form .formkit-input{background:#fff;font-size:15px;padding:12px;border:1px solid #e3e3e3;flex:1 0 auto;line-height:1.4;margin:0;transition:border-color .3s ease-out}.formkit-form .formkit-input:focus{outline:none;border-color:#1677be;transition:border-color .3s ease}.formkit-form .formkit-input::-webkit-input-placeholder{color:#848585}.formkit-form .formkit-input:-ms-input-placeholder{color:#848585}.formkit-form .formkit-input::-ms-input-placeholder{color:#848585}.formkit-form .formkit-input::placeholder{color:#848585}.formkit-form [data-group=dropdown]{position:relative;display:inline-block;width:100%}.formkit-form [data-group=dropdown]:before{content:"";top:calc(50% - 2.5px);right:10px;position:absolute;pointer-events:none;border-color:#4f4f4f transparent transparent;border-style:solid;border-width:6px 6px 0;height:0;width:0;z-index:999}.formkit-form [data-group=dropdown] select{height:auto;width:100%;cursor:pointer;color:#333;line-height:1.4;margin-bottom:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:15px;padding:12px 25px 12px 12px;border:1px solid #e3e3e3;background:#fff}.formkit-form [data-group=dropdown] select:focus{outline:none}.formkit-form [data-group=checkboxes]{text-align:left;margin:0}.formkit-form [data-group=checkboxes] [data-group=checkbox]{margin-bottom:10px}.formkit-form [data-group=checkboxes] [data-group=checkbox] *{cursor:pointer}.formkit-form [data-group=checkboxes] [data-group=checkbox]:last-of-type{margin-bottom:0}.formkit-form [data-group=checkboxes] [data-group=checkbox] input[type=checkbox]{display:none}.formkit-form [data-group=checkboxes] [data-group=checkbox] input[type=checkbox]+label:after{content:none}.formkit-form [data-group=checkboxes] [data-group=checkbox] input[type=checkbox]:checked+label:after{border-color:#fff;content:""}.formkit-form [data-group=checkboxes] [data-group=checkbox] input[type=checkbox]:checked+label:before{background:#10bf7a;border-color:#10bf7a}.formkit-form [data-group=checkboxes] [data-group=checkbox] label{position:relative;display:inline-block;padding-left:28px}.formkit-form [data-group=checkboxes] [data-group=checkbox] label:after,.formkit-form [data-group=checkboxes] [data-group=checkbox] label:before{position:absolute;content:"";display:inline-block}.formkit-form [data-group=checkboxes] [data-group=checkbox] label:before{height:16px;width:16px;border:1px solid #e3e3e3;background:#fff;left:0;top:3px}.formkit-form [data-group=checkboxes] [data-group=checkbox] label:after{height:4px;width:8px;border-left:2px solid #4d4d4d;border-bottom:2px solid #4d4d4d;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);left:4px;top:8px}.formkit-form .formkit-alert{background:#f9fafb;border:1px solid #e3e3e3;border-radius:5px;flex:1 0 auto;list-style:none;margin:25px auto;padding:12px;text-align:center;width:100%}.formkit-form .formkit-alert:empty{display:none}.formkit-form .formkit-alert-success{background:#d3fbeb;border-color:#10bf7a;color:#0c905c}.formkit-form .formkit-alert-error{background:#fde8e2;border-color:#f2643b;color:#ea4110}.formkit-form .formkit-spinner{display:flex;height:0;width:0;margin:0 auto;position:absolute;top:0;left:0;right:0;overflow:hidden;text-align:center;transition:all .3s ease-in-out}.formkit-form .formkit-spinner>div{margin:auto;width:12px;height:12px;background-color:#fff;opacity:.3;border-radius:100%;display:inline-block;-webkit-animation:formkit-bouncedelay-formkit-form-data-uid-4a352cb1fd- 1.4s ease-in-out infinite both;animation:formkit-bouncedelay-formkit-form-data-uid-4a352cb1fd- 1.4s ease-in-out infinite both}.formkit-form .formkit-spinner>div:first-child{-webkit-animation-delay:-.32s;animation-delay:-.32s}.formkit-form .formkit-spinner>div:nth-child(2){-webkit-animation-delay:-.16s;animation-delay:-.16s}.formkit-form .formkit-submit[data-active] .formkit-spinner{opacity:1;height:100%;width:50px}.formkit-form .formkit-submit[data-active] .formkit-spinner~span{opacity:0}@-webkit-keyframes formkit-bouncedelay-formkit-form-data-uid-4a352cb1fd-{0%,80%,to{-webkit-transform:scale(0);transform:scale(0)}40%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-4a352cb1fd-{0%,80%,to{-webkit-transform:scale(0);transform:scale(0)}40%{-webkit-transform:scale(1);transform:scale(1)}}.formkit-form{box-shadow:0 2px 15px 0 rgba(210,214,220,.5);max-width:700px;overflow:hidden}.formkit-form [data-style=full]{width:100%;display:block}.formkit-form .formkit-header{margin-top:0;margin-bottom:20px;font-family:inherit}.formkit-form .formkit-subheader{margin:15px 0}.formkit-form .formkit-column{background-size:cover;background-repeat:no-repeat;background-position:50%;padding:20px}.formkit-form .formkit-column:nth-child(2){border-top:1px solid #e9ecef}.formkit-form .formkit-field{margin:0 0 15px}.formkit-form .formkit-input,.formkit-form .formkit-submit{width:100%}.formkit-form .formkit-guarantee{font-size:13px;margin:0 0 15px}.formkit-form .formkit-guarantee>p{margin:0}.formkit-form .formkit-powered-by{color:#7d7d7d;display:block;font-size:12px;margin-bottom:0;text-align:center}.formkit-form .formkit-powered-by[data-active=false]{opacity:.5}.formkit-form[min-width~="600"] [data-style=full],.formkit-form[min-width~="700"] [data-style=full],.formkit-form[min-width~="800"] [data-style=full]{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr))}.formkit-form[min-width~="600"] .formkit-submit,.formkit-form[min-width~="700"] .formkit-submit,.formkit-form[min-width~="800"] .formkit-submit{width:auto}.formkit-form[min-width~="600"] .formkit-column,.formkit-form[min-width~="700"] .formkit-column,.formkit-form[min-width~="800"] .formkit-column{padding:40px}.formkit-form[min-width~="600"] .formkit-column:nth-child(2),.formkit-form[min-width~="700"] .formkit-column:nth-child(2),.formkit-form[min-width~="800"] .formkit-column:nth-child(2){border-top:none}</style><meta name="generator" content="Gatsby 2.0.91"/><style type="text/css">
    .anchor {
      float: left;
      padding-right: 4px;
      margin-left: -20px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var offset = element.offsetTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="alternate" type="application/rss+xml" title="Dan Abramov&#x27;s Overreacted Blog RSS Feed" href="/rss.xml"/><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><title data-react-helmet="true">useEffect完全ガイド — Overreacted</title><meta data-react-helmet="true" name="theme-color" content="#282c35"/><meta data-react-helmet="true" name="description" content="エフェクトはデータフローの一部"/><meta data-react-helmet="true" property="og:url" content="https://overreacted.io/ja/a-complete-guide-to-useeffect/"/><meta data-react-helmet="true" property="og:title" content="useEffect完全ガイド"/><meta data-react-helmet="true" property="og:description" content="エフェクトはデータフローの一部"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="@dan_abramov"/><meta data-react-helmet="true" name="twitter:title" content="useEffect完全ガイド"/><meta data-react-helmet="true" name="twitter:description" content="エフェクトはデータフローの一部"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.75 'Merriweather','Georgia',serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.9);font-family:'Merriweather','Georgia',serif;font-weight:400;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:Montserrat,sans-serif;font-weight:900;text-rendering:optimizeLegibility;font-size:2.5rem;line-height:1.1;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1.73286rem;line-height:1.1;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1.4427rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;letter-spacing:0.140625em;text-transform:uppercase;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:0.83255rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;color:inherit;font-family:'Merriweather','Georgia',serif;font-weight:900;text-rendering:optimizeLegibility;font-size:0.75966rem;line-height:1.1;font-style:italic;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}ul{margin-left:1.75rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;list-style-position:outside;list-style-image:none;list-style:disc;}ol{margin-left:1.75rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:0.85rem;line-height:1.75rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:1rem;line-height:1.75rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}blockquote{margin-left:-1.75rem;margin-right:1.75rem;margin-top:0;padding-bottom:0;padding-left:1.42188rem;padding-right:0;padding-top:0;margin-bottom:1.75rem;font-size:1.20112rem;line-height:1.75rem;color:inherit;font-style:italic;border-left:0.32813rem solid hsla(0,0%,0%,0.9);border-left-color:inherit;opacity:0.8;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.75rem - 1px);background:var(--hr);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.75rem;}b{font-weight:700;}strong{font-weight:700;}dt{font-weight:700;}th{font-weight:700;}li{margin-bottom:calc(1.75rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.75rem;margin-bottom:calc(1.75rem / 2);margin-top:calc(1.75rem / 2);}li > ul{margin-left:1.75rem;margin-bottom:calc(1.75rem / 2);margin-top:calc(1.75rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.75rem / 2);}code{font-size:0.85rem;line-height:1.75rem;}kbd{font-size:0.85rem;line-height:1.75rem;}samp{font-size:0.85rem;line-height:1.75rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.16667rem;padding-right:1.16667rem;padding-top:0.875rem;padding-bottom:calc(0.875rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}blockquote > :last-child{margin-bottom:0;}blockquote cite{font-size:1rem;line-height:1.75rem;color:hsla(0,0%,0%,0.9);font-weight:400;}blockquote cite:before{content:"— ";}ul,ol{margin-left:0;}@media only screen and (max-width:480px){ul,ol{margin-left:1.75rem;}blockquote{margin-left:-1.3125rem;margin-right:0;padding-left:0.98438rem;}}h1,h2,h3,h4,h5,h6{margin-top:3.5rem;}a{box-shadow:0 1px 0 0 currentColor;color:var(--textLink);text-decoration:none;}a:hover,a:active{box-shadow:none;}mark,ins{background:#007acc;color:white;padding:0.10938rem 0.21875rem;text-decoration:none;}a.gatsby-resp-image-link{box-shadow:none;}a.anchor{box-shadow:none;}a.anchor svg[aria-hidden="true"]{stroke:var(--textLink);}p code{font-size:1rem;}h1 code, h2 code, h3 code, h4 code, h5 code, h6 code{font-size:inherit;}li code{font-size:1rem;}blockquote.translation{font-size:1em;}</style><link as="script" rel="preload" href="/component---src-templates-blog-post-js-5ff9d93420b5b2cefece.js"/><link as="script" rel="preload" href="/app-83825dcbe188439d174e.js"/><link as="script" rel="preload" href="/0-b197e8c6c7ff26484233.js"/><link as="script" rel="preload" href="/2-31a6021f1637c5720eda.js"/><link as="script" rel="preload" href="/1-1b550cd61a5e170131aa.js"/><link as="script" rel="preload" href="/webpack-runtime-dea655677e505366ecd7.js"/><link as="fetch" rel="preload" href="/static/d/472/path---ja-a-complete-guide-to-useeffect-ae-9-e23-LvXwMLbvzwf7aFMogprKT2cg6dg.json" crossorigin="use-credentials"/></head><body class="light"><script>
              (function() {
                window.__onThemeChange = function() {};
                function setTheme(newTheme) {
                  window.__theme = newTheme;
                  preferredTheme = newTheme;
                  document.body.className = newTheme;
                  window.__onThemeChange(newTheme);
                }

                var preferredTheme;
                try {
                  preferredTheme = localStorage.getItem('theme');
                } catch (err) { }

                window.__setPreferredTheme = function(newTheme) {
                  setTheme(newTheme);
                  try {
                    localStorage.setItem('theme', newTheme);
                  } catch (err) {}
                }

                var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
                darkQuery.addListener(function(e) {
                  window.__setPreferredTheme(e.matches ? 'dark' : 'light')
                });

                setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
              })();
            </script><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div style="color:var(--textNormal);background:var(--bg);transition:color 0.2s ease-out, background 0.2s ease-out;min-height:100vh"><div style="margin-left:auto;margin-right:auto;max-width:42rem;padding:2.625rem 1.3125rem"><header style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2.625rem"><h3 style="font-family:Montserrat, sans-serif;margin-top:0;margin-bottom:0;height:42px;line-height:2.625rem"><a style="box-shadow:none;text-decoration:none;color:rgb(255, 167, 196)" href="/">Overreacted</a></h3><div style="height:24px"></div></header><main><article><header><h1 style="color:var(--textTitle)">useEffect完全ガイド</h1><p style="font-size:0.83255rem;line-height:1.75rem;display:block;margin-bottom:1.75rem;margin-top:-1.4rem">2019 M03 9<!-- --> • 🍱🍱 31 min read</p><div class="translations"><p style="font-size:0.9em;border:1px solid var(--hr);border-radius:0.75em;padding:0.75em;background:var(--inlineCode-bg);word-break:keep-all;font-family:system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;,
    &quot;Roboto&quot;, &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;, &quot;Fira Sans&quot;,
    &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif"><span><span>Translated by readers into: </span><a href="/pt-br/a-complete-guide-to-useeffect/">Português do Brasil</a> • <b>日本語</b> • <a href="/zh-hans/a-complete-guide-to-useeffect/">简体中文</a> • <a href="/zh-hant/a-complete-guide-to-useeffect/">繁體中文</a></span><br/><br/><a href="/a-complete-guide-to-useeffect/">Read the original</a> • <a href="https://github.com/gaearon/overreacted.io/edit/master/src/pages/a-complete-guide-to-useeffect/index.ja.md" target="_blank" rel="noopener noreferrer">Improve this translation</a> • <a href="/ja">View all translated posts</a> </p></div></header><div><p>あなたは Hooks を使って複数のコンポーネントを書きました。ちょっとしたアプリも作ったことがあるでしょう。満足もしている。API にも慣れて、その過程でコツも掴んできました。しかも重複したロジックを転用できるよう Custom Hooks を作り、同僚に自慢して見たり。</p>
<p>でも useEffect を使う度、いまいちピンときません。class のライフサイクルとは似ているけど、何かが違う。そしていろんな疑問を抱き始めます。</p>
<ul>
<li>🤔 <code class="language-text">componentDidMount</code> を <code class="language-text">useEffect</code> で再現する方法は？</li>
<li>🤔 <code class="language-text">useEffect</code> 内で正確に非同期処理を行う方法とは？　<code class="language-text">[]</code>ってなに？</li>
<li>🤔 関数をエフェクトの依存関係として記すべき？</li>
<li>🤔 非同期処理の無限ループがたまに起こるのはなぜ？</li>
<li>🤔 古い state か props がエフェクト内にたまに入るのはなぜ？</li>
</ul>
<p>私も Hooks を使い始めた時、同じような疑問を抱いてました。ドキュメントを書き始めた時も、まだ完璧に理解していませんでした。今回は、私がその後経験した アハモーメントを共有します。<strong>この記事を読むことによって、上記に挙げた質問を当たり前にわかるようになるでしょう。</strong></p>
<p>答えが見えるようになるには、一歩下がって全体図を俯瞰して理解する必要があります。この記事の目的は箇条書きで答えを教えることではなく、 <code class="language-text">useEffect</code> を完璧に理解していただくことです。習うことはそれほど多くはありません。それどころか、覚えていることを意識的に忘れることに注力していきます。</p>
<p><strong><code class="language-text">useEffect</code> Hook を慣れている class のライフサイクルパラダイムと分離して初めて理解できました。</strong></p>
<blockquote>
<p>“覚えたことを全て忘れるのじゃ.” — Yoda</p>
</blockquote>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 497px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 64.38631790744466%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAwX/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAF5WKs71REF/8QAGxAAAQUBAQAAAAAAAAAAAAAAAgABAxESEyH/2gAIAQEAAQUCvzvk9Woz0njdBK5j/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EAB0QAAICAQUAAAAAAAAAAAAAAAABAhEhMTJBUZH/2gAIAQEABj8CK4Nno10Obm8FvU//xAAbEAEBAQEAAwEAAAAAAAAAAAABEQAhMVFxgf/aAAgBAQABPyH0Zd076TuCbR9Rz80qZiwUvg37TTf/2gAMAwEAAgADAAAAEEPf/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERMUH/2gAIAQMBAT8QlaUf/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAECAQE/EFOQF//EABwQAQEAAgIDAAAAAAAAAAAAAAERACExQVFx0f/aAAgBAQABPxA0TUOLkyoSi0+4SldSl6yfaQttpzhvHAwULvWAwOi0F8zP/9k='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="空気を嗅ぐヨーダ. キャプション: “ベーコンの匂いがする.”"
        title=""
        src="/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg"
        srcset="/static/6203a1f1f2c771816a5ba0969baccd12/5645f/yoda.jpg 148w,
/static/6203a1f1f2c771816a5ba0969baccd12/3f2ca/yoda.jpg 295w,
/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg 497w"
        sizes="(max-width: 497px) 100vw, 497px"
      />
    </span>
  </span>
  
  </a>
    </p>
<hr>
<p><strong>この記事は <a href="https://ja.reactjs.org/docs/hooks-effect.html" target="_blank" rel="nofollow noopener noreferrer"><code class="language-text">useEffect</code></a> API をある程度理解していることが前提です</strong></p>
<p><strong>しかも<em>すごい</em>長文です。小さな本並みです。私が個人的に好むフォーマットなので、もし急ぎもしくはそこまで興味ない場合は、下に TLDR を書いたのでそちらを読んでください</strong></p>
<p><strong>もしこのようなディープダイブがしっくりこない場合は、他で説明されるのを待ったほうがいいかもしれません。React が 2013 年に出た時と同じように、人々が新たなメンタルモデルを理解して教えるのには時間がかかります。</strong></p>
<p>—</p>
<h2 id="tldr（長すぎ、読んでない）"><a href="#tldr%EF%BC%88%E9%95%B7%E3%81%99%E3%81%8E%E3%80%81%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%AA%E3%81%84%EF%BC%89" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TLDR（長すぎ、読んでない）</h2>
<p>このセクションには全てを読みたくない人向けに簡潔に質問に答えています。理解できない部分があれば、下にスクロールしてその部分に関係あるところを読んでください。</p>
<p>この記事を全て読むのであれば遠慮なくこのセクションは飛ばしてください。最後にリンクを貼ります。</p>
<p><strong>🤔 <code class="language-text">componentDidMount</code>を<code class="language-text">useEffect</code>で再現する方法は？</strong></p>
<p><code class="language-text">useEffect(fn, [])</code> でも再現できますが、全く同じという訳ではありません。 <code class="language-text">componentDidMount</code> とは違い、props と state を<em>キャプチャー</em>します。なので、callback の中でも初期 props と state を参照できます。一番最新のなにかを参照したい場合は、ref として書けます。ですが大概は ref として書かなくてもいいようコードを構成する方法があります。覚えて欲しいことは、effects と <code class="language-text">componentDidMount</code> や他のライフサイクルメソッドのメンタルモデルは別であることです。なので、それぞれのライフサイクルメソッドの代用を探そうとすると余計に混乱してしまいます。効率的になるためには「エフェクトで考える」必要があり、そのメンタルモデルはライフサイクルイベントに反応することではなく props や state の変化を DOM にシンクロさせる、という方に近いです。</p>
<p><strong>🤔 <code class="language-text">useEffect</code> 内で正確に非同期処理を行う方法とは？ <code class="language-text">[]</code> ってなに？</strong></p>
<p>この<a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="nofollow noopener noreferrer">記事</a>を参考にしてみると良いでしょう。最後まで読むように！この記事ほど長くはありません。<code class="language-text">[]</code>は、エフェクトは React のデータフローに携わる値をなに一つ使用していないので、一度だけ実行しても良いということを示していてます。ですが値が実際にエフェクト内で<em>使用</em>されている場合はバグの根源ともなります。依存関係を解消して正しく値を省くには複数のテクニック（主に <code class="language-text">useReducer</code> と <code class="language-text">useCallback</code> ）を用いる必要があります。</p>
<p><strong>🤔 関数をエフェクトの依存関係として記すべき？</strong></p>
<p>推薦される方法としては props や state を必要としない関数は<em>コンポーネント外</em>にホイスティングして、エフェクトでしか使われない関数は<em>エフェクト内</em>に入れる方法です。しかしそのあとにもエフェクトがレンダースコープ内の関数を使うことがあるのであれば（props からの関数も含む）、 <code class="language-text">useCallback</code> で関数が定義されている場所をラップしてそのプロセスをリピートします。なぜそれが大事かというと、関数は props や state を<em>見る</em>ことができるので、React のデータフローに携わるからです。詳しくは<a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="nofollow noopener noreferrer">FAQ</a>を参照してください。</p>
<p><strong>🤔 非同期処理の無限ループがたまに起こるのはなぜ？</strong></p>
<p>エフェクト内で非同期処理を依存関係を表す第二引数を与えないで実行すると起こります。第二引数がない場合、エフェクトは毎 render 時に走り、内部で state をセットしてると再度エフェクトをトリガーするからです。依存関係を表す第二引数に<em>常に</em>変わる値が入ってる場合でも無限ループは起きます。どれが問題の原因かは依存配列の中から値を一つ一つ削除していくことによって分かります。ですが、エフェクト内で使用してる値を依存配列から取り出したり（もしくは闇雲に <code class="language-text">[]</code> を指定したり）するのは大概に場合、正しくない直し方です。その代わり、問題の根源から直していきましょう。例えば、関数などがこの問題を起こしがちで、エフェクト内に定義するか、ホイスティングするか <code class="language-text">useCallback</code> でラップすると良いかもしれません。オブジェクトの再生成を阻止するために使われる <code class="language-text">useMemo</code> も同じような用途で使えます。</p>
<p><strong>🤔 古い state か props がエフェクト内にたまに入るのはなぜ？</strong></p>
<p>エフェクトは必ず定義された render の props と state を見ることができます。この方法は<a href="/ja/how-are-function-components-different-from-classes/">バグを阻止するのに有効</a>ですが、厄介と感じるケースもあります。その場合は、明確に値を mutable ref に保存すると良いでしょう（リンクされている記事の最後の方で説明してます）。もし古い render からの props や state を参照していて期待していない場合は、依存配列に何か入れ忘れている可能性があります。この<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="nofollow noopener noreferrer">lint ルール</a>を使って、入れ忘れないように慣れましょう。使い始めて数日経てば、習慣になるはずです。こちらの<a href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" target="_blank" rel="nofollow noopener noreferrer">FAQ</a>にも答えてるので参照してみてください。</p>
<hr>
<p>この TLDR が役に立ったなら嬉しいです。そうでなければ、深入りしていきましょう。</p>
<hr>
<h2 id="それぞれの-render-は独自の-props-と-state-を保持している"><a href="#%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E3%81%AE-render-%E3%81%AF%E7%8B%AC%E8%87%AA%E3%81%AE-props-%E3%81%A8-state-%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>それぞれの render は独自の props と state を保持している</h2>
<p>エフェクトに関して話す前に、レンダーリングについて話す必要があります。</p>
<p>まず、ここにはカウンターがあります。ハイライトされた行を見てください：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="gatsby-highlight-code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text"></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>どういうことでしょう？ <code class="language-text">count</code> は何とか props と state の変更を検知して自動的にアップデートされているのでしょうか？このメンタルモデルは React を学ぶ時の最初の直感としては役に立ちますが、実は<a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="nofollow noopener noreferrer">正しくありません</a>.</p>
<p><strong>このサンプルでは、 <code class="language-text">count</code> はただの数字です。</strong> データバインディングやウォッチャーやプロキシなど手の込んだものではありません。古き良きただの数字です：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre></div>
<p>コンポーネントが一番初めに render する際、<code class="language-text">useState()</code> から出力される <code class="language-text">count</code> 変数は <code class="language-text">0</code> です。<code class="language-text">setCount(1)</code>を呼ぶと、React はコンポーネントは再度呼び出します。その際、 <code class="language-text">count</code> は <code class="language-text">1</code> となります：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render 時</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// useState()の戻り値</span></span>  <span class="token comment">// ...</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// クリック後、関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// useState()の戻り値</span></span>  <span class="token comment">// ...</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// もう一度クリックすると、再度呼ばれる</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// useState()の戻り値</span></span>  <span class="token comment">// ...</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><strong>state をアップデートする度、React はコンポーネント関数を呼び出します。それぞれの render 結果は<em>定数として定義</em>された <code class="language-text">counter</code> state を<em>見る</em>ことができます</strong></p>
<p>したがって、この行は何も特別なデータバインディングをしてるわけではありません：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre></div>
<p><strong>何をしてるかというと、render 結果に数字を組み込んでいるだけです。</strong> この数字は React が提供しています。 <code class="language-text">setCount</code> すると、React は違った <code class="language-text">count</code> の値を使ってコンポーネントを呼び出しています。そして、render 結果にマッチするよう DOM をアップデートしてるのです。</p>
<p>ここで覚えていて欲しいのは <code class="language-text">count</code> 定数は特定の render で時間の経過と共に変化するのではないということです。何が起こってるかというと、コンポーネント関数が呼び出されているのです - そして各 render はそれぞれその render に隔離された <code class="language-text">count</code>値を <code class="language-text">見る</code> ことができるのです。</p>
<p><em>（このプロセスについてもっと深掘りしたい場合は<a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="nofollow noopener noreferrer">React as a UI Runtime</a>を参照してください。）</em></p>
<h2 id="それぞれの-render-は独自のイベントハンドラを保持している"><a href="#%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E3%81%AE-render-%E3%81%AF%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>それぞれの render は独自のイベントハンドラを保持している</h2>
<p>ここまでは順調ですね。ではイベントハンドラはどうでしょう？</p>
<p>この例を見てみてください。3 秒後に <code class="language-text">count</code> の値を alert するイベントです：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">アラートを表示</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line"><span class="token punctuation">}</span></span></code></pre></div>
<p>このような手順を踏んだとしましょう：</p>
<ul>
<li>count を 3 まで<strong>増やす</strong></li>
<li>“アラートを表示”を<strong>押下</strong></li>
<li>タイムアウトが発火する前に count を 5 まで<strong>増やす</strong></li>
</ul>
<p><img src="/counter-46c55d5f1f749462b7a173f1e748e41e.gif" alt="カウンターデモ"></p>
<p>アラートは何を表示するでしょう？アラートが表示される時の count state の 5 を表示するでしょうか？それとも押下した時の count state の 3 を表示するでしょうか？</p>
<hr>
<p><em>この先ネタバレ</em></p>
<hr>
<p>自分で一度<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="nofollow noopener noreferrer">再現してみてください！</a></p>
<p>もしこの挙動が意味をなさない場合は、もっと現実的な例を想像してみてください：受取人 ID を state に保持するチャットアプリと、送るボタンなど。<a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="nofollow noopener noreferrer">この記事</a>が理由を深掘りしていますが正解は 3 です。</p>
<p>アラートは押下時の state をキャプチャーします。</p>
<p><em>（5 を表示させるような実装をする方法はありますが、今回はデフォルトケースにフォーカスします。メンタルモデルを構築する際は最も容易な方法と避難ハッチを明確に区別する必要があります）</em></p>
<hr>
<p>なぜこのような挙動をするのでしょう？</p>
<p>先ほど、 <code class="language-text">count</code> は定数であり呼び出される関数ごとに保持していると議論しました。<strong>関数は何度も呼ばれる（render 毎に一度）が、その都度 <code class="language-text">count</code>値は定数であり何かの値でセットされている（その render の state）</strong> というのは強調する価値があります。</p>
<p>これは React 特有の挙動ではありません。通常の関数も同じような挙動をします：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> name <span class="token operator">=</span> person<span class="token punctuation">.</span>name<span class="token punctuation">;</span></span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"こんにちは, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> someone <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Dan"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">sayHi</span><span class="token punctuation">(</span>someone<span class="token punctuation">)</span><span class="token punctuation">;</span>

someone <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Yuzhi"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">sayHi</span><span class="token punctuation">(</span>someone<span class="token punctuation">)</span><span class="token punctuation">;</span>

someone <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Dominic"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">sayHi</span><span class="token punctuation">(</span>someone<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>この<a href="https://codesandbox.io/s/mm6ww11lk8" target="_blank" rel="nofollow noopener noreferrer">例</a>では、someone という変数が何度も再代入されてます（React 上のどこかと同じように、<em>現在</em>のコンポーネント state も代わり得ます。）<strong>ですが、sayHi 関数の中にはローカル name 定数が存在しており、その定数は特定の呼び出しとその引数で与えられた <code class="language-text">person</code> に紐づいています</strong> name 定数はローカルなので、呼び出しごとに隔離されています！結果、タイムアウトが発火される時、それぞれの alert は 引数で与えられた <code class="language-text">name</code> を<em>覚えて</em>います。</p>
<p>上の例がなぜイベントハンドラが押下時の <code class="language-text">count</code> を保持してるか説明してくれてます。同じような再代入の方針を採用した場合、それぞれの render は特定の <code class="language-text">count</code> が<em>見えて</em>います：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Returned by useState()</span></span>  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 押下されると、コンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Returned by useState()</span></span>  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 再押下後、またコンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Returned by useState()</span></span>  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>なので、実質的にはそれぞれの render は独自の <code class="language-text">handleAlertClick</code> のバージョンを返しています。そしてそれぞれのバージョンは 独自の <code class="language-text">count</code> を<em>覚えて</em>います：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="gatsby-highlight-code-line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span> <span class="token comment">// 0 が入ってるバージョン</span></span>  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 押下されると、コンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="gatsby-highlight-code-line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span> <span class="token comment">// 1 が入ってるバージョン</span></span>  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 再押下後、またコンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"You clicked on: "</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="gatsby-highlight-code-line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span> <span class="token comment">// 2 が入ってるバージョン</span></span>  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>この理由から、この<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="nofollow noopener noreferrer">デモ</a>の中でイベントハンドラは特定の render に属しており、押下するとその特定 render の中の <code class="language-text">counter</code> state を使っているのが分かります。</p>
<p><strong>特定の render の中では props と state は一生変わりません。</strong> props と state が特定の render に隔離されていて同じということは、それを使用してる値（イベントハンドラも含む）もそうです。その値も特定の render に属しているのです。なので、イベントハンドラ内の非同期関数さえも同じ <code class="language-text">count</code> の値を参照できます。</p>
<p><em>注記：上記の例で私は <code class="language-text">count</code> の値を直指定しました。<code class="language-text">count</code> の値は特定の render 内では変わり得ないので、この代入方法は安全です。定数で定義されていて数字です。オブジェクトなども同じように考えて問題ないと思いますが、それは mutate しないことが前提ならば、です。mutate する代わりに新しく作成されたオブジェクトで<code class="language-text">setSomething(newObj)</code>と呼び出すのは安全で、なぜかというと過去の render に属している state は損なわれていないからです。</em></p>
<h2 id="それぞれの-render-は独自のエフェクトを保持している"><a href="#%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E3%81%AE-render-%E3%81%AF%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>それぞれの render は独自のエフェクトを保持している</h2>
<p>この記事はエフェクトに関する記事のはずだったんですが、まだエフェクトのことについて話してませんでしたね！それでは今からそれを正しましょう。どうやら、エフェクトも他と何も変わりません。</p>
<p>このドキュメントにある<a href="https://ja.reactjs.org/docs/hooks-effect.html" target="_blank" rel="nofollow noopener noreferrer">例</a>に戻ってみましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><strong>ここであなたに質問です。エフェクトはどのようにして最新の <code class="language-text">count</code> state を読むと思いますか？</strong></p>
<p>データバインディングやウォッチャーがエフェクト関数内で <code class="language-text">count</code> の値をライブアップデートしてたり、もしくは <code class="language-text">count</code> は mutable な変数であり React がうまい具合に最新の値をセットしてるからエフェクト内でも最新の値を参照できてるのだと思うかもしれない。</p>
<p>でもそれは違う。</p>
<p><code class="language-text">count</code> は定数であり、特定の render に属しているというのは先ほど説明した。ある render に紐づいているイベントハンドラは同じスコープ内に属している <code class="language-text">count</code> の値を参照することができる。エフェクトも同じである。</p>
<p><strong>「変化」しないエフェクト内で <code class="language-text">count</code> 変数が変化している訳ではありません。 <em>エフェクト関数そのもの</em> が render ごとに異なっているのです</strong></p>
<p>それぞれのバージョンは特定の render 内の <code class="language-text">count</code> の値を参照することができます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// 初期 render のエフェクト関数</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">0</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 押下されると、コンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// 2回目の render のエフェクト関数</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 再押下後、またコンポーネント関数が呼び出される</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// 3回目の render のエフェクト関数</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span></code></pre></div>
<p>React はあなたが与えたエフェクト関数を覚えており、DOMに変更が走ってブラウザに描画された後に実行されます。</p>
<p>概念的には一つのエフェクト（ドキュメントのタイトルを変える）なのですが、render されるごとに <em>別の関数</em> として表されています - そしてそれぞれのエフェクト関数は特定の render に属する props と state を参照することができます。</p>
<p><strong>概念的に、エフェクトは <em>render 結果</em> の一部であると想像してもらってもいいです。</strong></p>
<hr>
<p>完全に理解してるか確認するために、初期 render で何が起こるかおさらいしましょう：</p>
<ul>
<li><strong>React：</strong> state が <code class="language-text">0</code> の時のUIをちょうだい。</li>
<li>
<p><strong>あなたのコンポーネント：</strong></p>
<ul>
<li>これが render 結果だよ：
<code class="language-text">&lt;p&gt;You clicked 0 times&lt;/p&gt;</code>.</li>
<li>それと、終わった後にこのエフェクトを実行するのを忘れないでね： <code class="language-text">() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>.</li>
</ul>
</li>
<li><strong>React：</strong> 了解。UIをアップデート中。ねぇブラウザ、DOMに色々追加してるよ</li>
<li><strong>ブラウザ：</strong> いいね。画面に描画したよ。</li>
<li>
<p><strong>React：</strong> 了解。では今から与えられたエフェクトを実行するよ。</p>
<ul>
<li><code class="language-text">() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>を実行中</li>
</ul>
</li>
</ul>
<hr>
<p>ではボタンをクリックしたらどうなるかもおさらいしておこう：</p>
<ul>
<li><strong>あなたのコンポーネント：</strong> ねぇ React, state を <code class="language-text">1</code> にセットして。</li>
<li><strong>React：</strong> state が <code class="language-text">1</code> の時のUIをちょうだい。</li>
<li>
<p><strong>あなたのコンポーネント：</strong></p>
<ul>
<li>これが render 結果だよ：
<code class="language-text">&lt;p&gt;You clicked 1 times&lt;/p&gt;</code>.</li>
<li>それと、終わった後にこのエフェクトを実行するのを忘れないでね： <code class="language-text">() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>.</li>
</ul>
</li>
<li><strong>React：</strong> 了解。UIをアップデート中。ねぇブラウザ、DOMに色々追加してるよ</li>
<li><strong>ブラウザ：</strong> いいね。画面に描画したよ。</li>
<li>
<p><strong>React：</strong> 了解。では今からこの特定の render に属するエフェクトを実行するよ。</p>
<ul>
<li><code class="language-text">() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>を実行中</li>
</ul>
</li>
</ul>
<hr>
<h2 id="それぞれの-render-は全てを保持している"><a href="#%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E3%81%AE-render-%E3%81%AF%E5%85%A8%E3%81%A6%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>それぞれの render は全てを保持している</h2>
<p><strong>エフェクトは render の後に実行され、概念的にはコンポーネント出力の一部であり、特定の render 内の state と props を参照できるというのは理解していただけたと思う</strong></p>
<p>思考実験をしてみましょう。このコードについて考えます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">You clicked </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text"> times</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">        Click me</span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>少し遅らせて複数回クリックすると、ログはどのような結果になるでしょうか？</p>
<hr>
<p><em>この先ネタバレ</em></p>
<hr>
<p>この質問はひっかけ問題であり直感的ではないと思われるでしょう。ですが違います！特定の render 内に属する <code class="language-text">count</code> の値が順次出力されます。ご自分で一度<a href="https://codesandbox.io/s/lyx20m1ol" target="_blank" rel="nofollow noopener noreferrer">試してみてください</a></p>
<p><img src="/timeout_counter-a5727d333c270e05942f508707265378.gif" alt="1, 2, 3, 4, 5 と順次出力される画面録画"></p>
<p>「当たり前じゃん！これ以外どのような挙動するの？」と思われるでしょう。</p>
<p>class コンポーネントの <code class="language-text">this.state</code> は、このような挙動をしませんよ。この<a href="https://codesandbox.io/s/kkymzwjqz3" target="_blank" rel="nofollow noopener noreferrer">コード</a>が同じような挙動をすると思うのはよくある勘違いです：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">this.state.count</code> は特定の render に属する値ではなく、常に最新の count の値を参照します。なので、代わりに <code class="language-text">5</code> が順番に表示されます：</p>
<p><img src="/timeout_counter_class-264b329edc111a1973003bdf2bcacd65.gif" alt="5, 5, 5, 5, 5 と順次出力される画面録画"></p>
<p>Hooks は JavaScript のクロージャに頼りきっているのに、class の実装がクロージャとよく関連づけられる<a href="https://wsvincent.com/javascript-closure-settimeout-for-loop/" target="_blank" rel="nofollow noopener noreferrer">タイムアウト内に違う値が入る不思議な現象</a>に苦しむなんて、皮肉ですね。なぜかというと、混同の元は mutation であり、（React は <code class="language-text">this.state</code> を mutate して最新の値を指すようにしてる）クロージャ自体ではありません。</p>
<p><strong>クロージャは、クローズする値が変わらない場合にとても役に立ちます。基本的に定数を参照するということなので、何も難しく考える必要がありません</strong> そして先ほどにも述べたように、 props と state は特定の render 内では一生変わりません。ちなみに、class のバージョンは直すことができます… <a href="https://codesandbox.io/s/w7vjo07055" target="_blank" rel="nofollow noopener noreferrer">クロージャを使って。</a></p>
<h2 id="流れに逆らう"><a href="#%E6%B5%81%E3%82%8C%E3%81%AB%E9%80%86%E3%82%89%E3%81%86" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流れに逆らう</h2>
<p>この時点で明示的に重要なことが言えます。それは、コンポーネント render 内の<strong>全て</strong>の関数（コンポーネント内で定義されてるイベントハンドラ、エフェクト、タイムアウト、APIの呼び出しなどを含む）は定義されてる特定の render 内の props と state をキャプチャーします。</p>
<p>なので、この二つの例は同様の挙動をします：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> counter <span class="token operator">=</span> props<span class="token punctuation">.</span>counter<span class="token punctuation">;</span></span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><strong>props か state を「早めに」コンポーネント内で呼ぼうが呼ばまいが関係ありません。</strong> なぜなら変わらないからです！一つの render 内のスコープでは、 props と state は変わりません。（分割代入するとさらに分かりやすいです。）</p>
<p>ですが、特定の render 内の値ではなく最新の値をエフェクト内で定義されてる callback内で <em>使いたい</em> 場合もありますよね。これを成し遂げる一番簡単な方法は、この<a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="nofollow noopener noreferrer">記事</a>の最後のセクションにも説明されてるように、 refs を使うことです。</p>
<p>ですが、 <em>未来の</em> props や state を読みたいということは React の流れに逆らっているというのを用心してください。間違ってはいません（そして時々必要）が、パラダイムから抜け出すという意味であまり
綺麗には見えないかもしれません。これは意図した仕様で、なぜかというとどのコードが脆く、タイミングに頼っているか洗い出しハイライトしてくれる役割を担っています。classes ではこの現象が起きてもあまり明らかにはされません。</p>
<p>こちらが class の動作と同じような動きをする counter の例です：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> latestCount <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// mutable な最新の値をセットする</span></span><span class="gatsby-highlight-code-line">    latestCount<span class="token punctuation">.</span>current <span class="token operator">=</span> count<span class="token punctuation">;</span></span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token comment">// mutable な最新の値を読む</span></span><span class="gatsby-highlight-code-line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>latestCount<span class="token punctuation">.</span>current<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span></code></pre></div>
<p><img src="/timeout_counter_refs-78f7948263dd13b023498b23cb99f4fc.gif" alt="S5, 5, 5, 5, 5 と順次出力される画面録画"></p>
<p>React で何かを mutate するという行為は風変わりに見えるかもしれません。ですが、まさにこの方法で React は classes の <code class="language-text">this.state</code> を reassign しています。特定の render でキャプチャーされた props と state とは違い、 <code class="language-text">latestCount.current</code> は特定の callback の値を変わらずに参照できる、とは限りません。定義上は、いつでも mutate 可能なのです。このような理由からデフォルトではなく、自分から選んで使う必要があります。</p>
<h2 id="では-cleanup-はどうでしょう？"><a href="#%E3%81%A7%E3%81%AF-cleanup-%E3%81%AF%E3%81%A9%E3%81%86%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%EF%BC%9F" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>では Cleanup はどうでしょう？</h2>
<p><a href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" target="_blank" rel="nofollow noopener noreferrer">ドキュメントで説明</a>されているように、一部のエフェクトは cleanup phase があるかもしれません。サブスクリプションなど、エフェクトを元に戻す役割を果たします。</p>
<p>このコードを見てください：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>初期 render 時には <code class="language-text">props</code> は <code class="language-text">{id: 10}</code> として、2回目の render 時は <code class="language-text">{id: 20}</code> になるとしましょう。このようなことが起きると思われるでしょう：</p>
<ul>
<li>React が <code class="language-text">{id: 10}</code> のエフェクトを cleanup する。</li>
<li>React が　<code class="language-text">{id: 20}</code> の UI を render する。</li>
<li>React が <code class="language-text">{id: 20}</code> のエフェクトを実行する。</li>
</ul>
<p>（ちょっと違います。）</p>
<p>このメンタルモデルでは、re-render 前に cleanup は実行されるので 古い props が見えていると思われるでしょう。そして、新しいエフェクトは re-render 後に実行されるので最新の props が見えていると。ですがこれは class のライフサイクルのメンタルモデルに基づいていて、ここでは <strong>正確ではありません。</strong> 理由を見ていきましょう。</p>
<p>React は<a href="https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f" target="_blank" rel="nofollow noopener noreferrer">ブラウザが描画した後</a>に初めてエフェクトを実行します。この方法だとスクリーンアップデートをブロックすることがないので、アプリを早くしてくれます。それと同様で、エフェクトの cleanup も遅れて実行されます。 <strong>前のエフェクトは新しい props で re-render されてから cleanup されます：</strong></p>
<ul>
<li>React が　<code class="language-text">{id: 20}</code> の UI を render する。</li>
<li>ブラウザが描画する。<code class="language-text">{id: 20}</code> の時の UI が画面に表示される。</li>
<li><strong>React が <code class="language-text">{id: 10}</code> のエフェクトを cleanup する。</strong></li>
<li>React が <code class="language-text">{id: 20}</code> のエフェクトを実行する。</li>
</ul>
<p>でもどうやって前のエフェクトの cleanup は props が <code class="language-text">{id: 20}</code> に変わって re-render された<em>後に</em>実行されてるのに、古い <code class="language-text">{id: 10}</code> の props が見えてるの？と思われるでしょう。</p>
<p>前にも遭遇した問題ですね… 🤔</p>
<p><img src="/deja_vu-5fe238cf03a21dfa32af624124fcdcff.gif" alt="デ・ジャヴ (映画マトリックスでの猫のシーン)"></p>
<p>前のセクションから引用します：</p>
<blockquote>
<p>コンポーネント render 内の<strong>全て</strong>の関数（コンポーネント内で定義されてるイベントハンドラ、エフェクト、タイムアウト、APIの呼び出しなどを含む）は定義されてる特定の render 内の props と state をキャプチャーします。</p>
</blockquote>
<p>これで答えは明確ですね！エフェクトの cleanup はどういう意味であろうと最新の値を読んだりしません。エフェクトが定義されている特定の render 内の props を読んでいるのです：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render 時、 props は {id: 10}</span>
<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token comment">// 初期 render のエフェクト関数</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">      <span class="token comment">// 初期 render のエフェクトを cleanup</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2回目の render 時、props は {id: 20}</span>
<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token comment">// 2回目の render のエフェクト関数</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 2回目の render のエフェクトを cleanup</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>帝国は滅び遺灰に変わり、太陽の外層は削ぎ落とされ白色矮星に変形し、最後の文明は終わりを迎えます。ですが誰も初期 render の cleanup を定義された特定の render 内の <code class="language-text">{id: 10}</code> 以外のものを cleanup させることはできません。</p>
<p>これらの理由により React は描画後エフェクトを実行するのです - デフォルトであなたのアプリを早くするために。古い props はコードが必要な時のために存在はしています。</p>
<h2 id="ライフサイクルではなく、シンクロ"><a href="#%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%8F%E3%80%81%E3%82%B7%E3%83%B3%E3%82%AF%E3%83%AD" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ライフサイクルではなく、シンクロ</h2>
<p>React の何が好きかっていうと、初期 render の結果記述とアップデートが統一されているところです。これによりプログラムの均質化を防ぐことができます。</p>
<p>このようなコンポーネントがあるとしましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Hello, </span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">&lt;Greeting name=&quot;Dan&quot; /&gt;</code> を render して後に <code class="language-text">&lt;Greeting name=&quot;Yuzhi&quot; &gt;</code> に変えようが、直接 <code class="language-text">&lt;Greeting name=&quot;Yuzhi&quot; /&gt;</code> を render しようが関係ありません。最終的には、どちらのケースでも “Hello, Yuzhi” と出力されます。</p>
<p>よく人は「すべては過程だ。結果ではない」と言います。ですが、 React の場合は逆です。<strong>全ては結果であり、過程ではありません。</strong> これが jQuery の <code class="language-text">$.addClass</code> と <code class="language-text">$.removeClass</code>（過程）などの呼び出しと React で<em>あるべき</em> CSS クラスを定義する行為（結果）の違いです。</p>
<p><strong>React は現在の props と state に応じて DOM をシンクロします。</strong> render 時は mount や update に区別はありません。</p>
<p>エフェクトを同じように考えるのが正解でしょう。<strong><code class="language-text">useEffect</code> は、React tree 以外のものを props と state に応じて <em>シンクロ</em> してくれます。</strong> </p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> name<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      Hello, </span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>これは、<em>mount/update/unmount</em> のメンタルモデルとは微妙に異なります。 これはしっかり理解しましょう。<strong>初期 render か否かで違う挙動をするエフェクトを書こうとしてる場合は、React の流れに逆らっています！</strong> もし、結果が <em>過程</em> に頼ってしまっている場合は、シンクロに失敗しています。</p>
<p>props A, B, と C と順に render しようが C でいきなり render しようが関係ないはずです。多少違いはあるかもしれませんが（例えば data を fetch している間など）、最終結果は同じであるはずです。</p>
<p>それでも、全てのエフェクトを render <em>毎</em>に実行させるのは効率的ではないかもしれません（そして場合によっては無限ループにも繋がります）。</p>
<p>どうしたら解決できるでしょうか？</p>
<h2 id="react-にエフェクトを比較することを教える"><a href="#react-%E3%81%AB%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%AF%94%E8%BC%83%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%92%E6%95%99%E3%81%88%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React にエフェクトを比較することを教える</h2>
<p>この教訓はもう既に DOM 操作で習っています。React は DOM がアップデートされた箇所だけ認識して、全てを触らずに変更点だけアップデートします。</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  Hello, Dan
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre></div>
<p>を</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  Hello, Yuzhi
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre></div>
<p>へアップデートするとします。この時、 React は二つのオブジェクトを受け取ります：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> oldProps <span class="token operator">=</span> <span class="token punctuation">{</span>className<span class="token punctuation">:</span> <span class="token string">'Greeting'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token string">'Hello, Dan'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>className<span class="token punctuation">:</span> <span class="token string">'Greeting'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token string">'Hello, Yuzhi'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>それぞれの props を比べて、 <code class="language-text">children</code> は変更しているので DOM アップデートは必要ですが <code class="language-text">className</code> は変わっていないので、このような処理をします：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">domNode<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'Hello, Yuzhi'</span><span class="token punctuation">;</span>
<span class="token comment">// domNode.classNameは触る必要なし</span></code></pre></div>
<p><strong>このような処理をエフェクトでもできるでしょうか？エフェクトを実行する必要がない場合は実行しない、とかできたらいいですよね。</strong></p>
<p>例えば、state の変更によりコンポーネントが再 render するかもしれません：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>counter<span class="token punctuation">,</span> setCounter<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      Hello, </span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token plain-text"></span>
<span class="gatsby-highlight-code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCounter</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></span><span class="gatsby-highlight-code-line"><span class="token plain-text">        Increment</span></span><span class="gatsby-highlight-code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>ですが、我々のエフェクトは <code class="language-text">counter</code> の state を使用していません。 <strong>このエフェクトは、<code class="language-text">document.title</code> を <code class="language-text">name</code> prop でシンクロさせています。ですが、 <code class="language-text">name</code> prop は変わりません。</strong> なので、 <code class="language-text">document.title</code> を <code class="language-text">counter</code> が変わるごとにリアサインするのは、効率的とは言えません。</p>
<p>React は単純に DOM の違いを勝手に検知できるようにエフェクトも違いを検知できないの？と思いますよね。</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">let</span> <span class="token function-variable function">oldEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, Dan'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">newEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, Dan'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// React はこの二つの関数が同じことをしているということが分かるのか？</span></code></pre></div>
<p>実はできません。React は一度関数を呼ばないと、その関数が何をしているか推測することはできません。</p>
<p>なので、もし不必要なエフェクトを再実行したくない場合は、依存配列（deps とも言われる）というものを第 2 引数として <code class="language-text">useEffect</code> に渡します：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Our deps</span></span></code></pre></div>
<p><strong>「関数の戻り値が分からないのは知ってるけど、render scope 内で <code class="language-text">name</code> しか使ってないことを約束するよ」と React に言ってるみたいなものです。</strong></p>
<p>もし配列内のそれぞれの値が現在と一つ前のエフェクト実行時と同じであれば、シンクロするものがないので React はエフェクトをスキップします：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">oldEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, Dan'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> oldDeps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dan'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">newEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, Dan'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newDeps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dan'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// React は関数の戻り値を分かることはできないが、deps を比べることはできる。</span>
<span class="token comment">// この例では、 deps は同じであるため新しいエフェクトを実行せずに済む。</span></code></pre></div>
<p>もし一つでも deps の値が render ごとに違ったら、エフェクトはスキップされてはならないというのが分かります。シンクロタイムだ！</p>
<h2 id="react-に依存関係の嘘をついてはならない"><a href="#react-%E3%81%AB%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AE%E5%98%98%E3%82%92%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E3%81%AA%E3%82%89%E3%81%AA%E3%81%84" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React に依存関係の嘘をついてはならない</h2>
<p>React に嘘をつくと、後に悪影響を与えることになる。直感的には理屈に合うのだが、class のメンタルモデルを流用して <code class="language-text">useEffect</code> を使う人たちはたくさん見てきました（そして自分も最初は同じでした！）。</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// これは適してるのでしょうか？必ずしもそうであるとは限りません - もっと良い方法があります。</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><em>（Hooks の <a href="https://ja.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="nofollow noopener noreferrer">FAQ</a> に詳しく方法を書いています。この例にはまた後で<a href="#moving-functions-inside-effects">戻ってきます</a>）</em></p>
<p>「でも、 mount 時だけに実行したい！」と思うかもしれません。とりあえず今はこれだけ覚えてください： deps を指定する場合、 <strong>コンポーネント内の値がありエフェクトでも使われてる場合は、全て記述してください。</strong> それはコンポーネント内の props, state, そして関数も含みます。</p>
<p>ですが稀に問題を引き起こす場合もあります。例えば、無限 refetch ループに出くわしたり、ソケットが何度も作られたり。 <strong>これらの解決策は対象 deps を配列内から削除することではありません。</strong> 最善の解決策は後ほどお見せします。</p>
<p>ですが解決策を見る前に、なぜ起こるのか探っていきましょう。</p>
<h2 id="依存関係に嘘をつくと何が起こるのか"><a href="#%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AB%E5%98%98%E3%82%92%E3%81%A4%E3%81%8F%E3%81%A8%E4%BD%95%E3%81%8C%E8%B5%B7%E3%81%93%E3%82%8B%E3%81%AE%E3%81%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>依存関係に嘘をつくと何が起こるのか</h2>
<p>もしエフェクト内で使われてる全ての値が deps に含まれていると、 React はいつエフェクトを再実行するか分かります：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre></div>
<p><img src="/deps-compare-correct-fae247cd068eedbd4b62ba50592d2b3d.gif" alt="エフェクトが入れ替わってる様子"></p>
<p><em>（依存する値が render 後に異なるため、エフェクトを再実行します。）</em></p>
<p>ですが依存配列を <code class="language-text">[]</code> とした場合、最新のエフェクトは実行されません：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 間違い： name が deps に入ってません</span></span></code></pre></div>
<p><img src="/deps-compare-wrong-25f75db3f9f57ffe1426912093577445.gif" alt="エフェクトが入れ替わってる様子"></p>
<p><em>（依存する値が render 後も同じなので、エフェクトをスキップします。）</em></p>
<p>ぱっと見だとこの問題は当たり前だと思うかもしれません。ですが、直感的に class での解決策が思い浮かんで混乱することもあります。</p>
<p>例えば、毎秒 1 づつ increment していくカウンターコンポーネントを作成してるとしましょう。 class のメンタルモデルでは setInterval を一度だけセットして、それを終わり次第 destroy するのが直感的に思い浮かぶでしょう。こちらが実際に実装した<a href="https://codesandbox.io/s/n5mjzjy9kl" target="_blank" rel="nofollow noopener noreferrer">例</a>です。このコードを <code class="language-text">useEffect</code> のメンタルモデルに置き換えると、直感的に <code class="language-text">[]</code> を deps に与えてしまいます。なぜなら一度だけ実行したいからでしょ？</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>ですが、この例だと<a href="https://codesandbox.io/s/91n5z8jo7r" target="_blank" rel="nofollow noopener noreferrer">一度しか increment しません</a> 。<em>あれ？</em></p>
<p>あなたのメンタルモデルが「依存配列は再実行したいタイミングを指定させてくれる」だと、この例であなたは自分の存在意義を問うことになるでしょう。intervalなので一度だけ実行 <em>したい</em> のに、何が問題を引き起こしているのでしょうか？</p>
<p>ですが、dependencies は React に対してエフェクトが render scope 内で使う <em>全て</em> の値に対するヒントであるというのを知っていると、理にかなってます。エフェクト内で <code class="language-text">count</code> を使っているのに、依存配列に <code class="language-text">[]</code> と指定することで嘘をつきました。バグを引き起こすのも時間の問題です。</p>
<p>初期 render 時は、 <code class="language-text">count</code> は <code class="language-text">0</code> です。なので、 <code class="language-text">setCount(count + 1)</code> は初期 render のエフェクトでは <code class="language-text">setCount(0 + 1)</code> という意味です。 <strong><code class="language-text">[]</code> を指定してるので再実行はされません。なので、 <code class="language-text">setCount(0 + 1)</code> を毎秒呼び続けているのです：</strong></p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render 時は state = 0</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token comment">// 初期 render のエフェクト</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">        <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Always setCount(1)</span></span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="gatsby-highlight-code-line">    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 初期以降二度と実行されない</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// その後全ての render では state = 1</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// このエフェクトは常に無視される。</span></span><span class="gatsby-highlight-code-line">    <span class="token comment">// なぜなら、空配列と嘘をついたからである。</span></span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>コンポーネント内の値に依存しているのに、 エフェクトはどの値にも依存していないと嘘をつきました！</p>
<p>このエフェクトは、コンポーネント内にはあるがエフェクト内にはない <code class="language-text">count</code> の値を使っています：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token comment">// ...</span></span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>なので、 依存配列に <code class="language-text">[]</code> と指定するとバグを起こします。 React は依存配列の中身の値を比較し、エフェクトをスキップします：</p>
<p><img src="/interval-wrong-29e53bd0c9b7d2ac70d3cd924886b030.gif" alt="古い interval の closure の図"></p>
<p><em>（配列内の値が同じなので、エフェクトをスキップします。）</em></p>
<p>このような難題は理解に苦しみます。なので、エフェクト内の依存関係については常に正直であることをルール化するのをオススメします。もしチーム内で徹底する場合は、<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="nofollow noopener noreferrer">lint rule</a> を提供しています。</p>
<h2 id="依存関係に正直になる二つの方法"><a href="#%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AB%E6%AD%A3%E7%9B%B4%E3%81%AB%E3%81%AA%E3%82%8B%E4%BA%8C%E3%81%A4%E3%81%AE%E6%96%B9%E6%B3%95" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>依存関係に正直になる二つの方法</h2>
<p>依存関係に正直なる方法として、二つの方針があります。一般的には最初の策で始めて、二個目の策は必要であれば適用してください。</p>
<p><strong>コンポーネント内で定義されていて、エフェクト内で使われている全ての値を依存配列の中に入れてください。それが一つ目の方法です。</strong>　<code class="language-text">count</code> を deps として入れてみましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre></div>
<p>これで、依存配列は正しくなりました。<em>最適な</em> 方法とは言えませんが、これが一番初めに直すべきことです。これで、 <code class="language-text">count</code> の値が変わればエフェクトは再実行されて、 <code class="language-text">setCount(count + 1)</code> はその render に定義されている <code class="language-text">count</code> を正しく参照します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 初期 render 時、state = 0</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token comment">// 初期 render 時のエフェクト</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">        <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setCount(count + 1)</span></span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="gatsby-highlight-code-line">    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// [count]</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2回目の render 時、state = 1</span>
<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token comment">// 2回目の render 時のエフェクト</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">        <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setCount(count + 1)</span></span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="gatsby-highlight-code-line">    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// [count]</span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>こうすることによって<a href="https://codesandbox.io/s/0x0mnlyq8l" target="_blank" rel="nofollow noopener noreferrer">この問題</a>は解決されますが、 <code class="language-text">count</code> が変わる度に interval が clear されてしまいます。これは望ましくないかもしれません：</p>
<p><img src="/interval-rightish-5734271ddfa94d2d65ac6160515e0069.gif" alt="re-subscribe する interval の図"></p>
<p><em>（依存配列の中の値が違うので、エフェクトを再実行します。）</em></p>
<hr>
<p><strong>よく変わる値をそもそも<em>必要</em>としないエフェクトにコードを書き換えるというのが、二つ目の方法です。</strong> 依存関係について嘘はつきたくはありません - なので、エフェクト内の依存する値を<em>減らす</em>のです。</p>
<p>依存配列の中身を減らす方法をみていきましょう。</p>
<hr>
<h2 id="自律的なエフェクトを作る"><a href="#%E8%87%AA%E5%BE%8B%E7%9A%84%E3%81%AA%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自律的なエフェクトを作る</h2>
<p><code class="language-text">count</code> の値をエフェクトから出したいとしましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre></div>
<p>そうするには、まずなぜ <code class="language-text">count</code> が必要なのか考えましょう。 <code class="language-text">setCount</code> の中でしか使ってないように見えます。この場合だと、 <code class="language-text">count</code> をスコープ内に含める必要は実はありません。前の state に基づいて state をアップデートしたい場合は、<code class="language-text">setState</code> の<a href="https://ja.reactjs.org/docs/hooks-reference.html#functional-updates" target="_blank" rel="nofollow noopener noreferrer">関数型の更新</a>を使えます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">setCount</span><span class="token punctuation">(</span>c <span class="token operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>このようなケースを僕は「不正な依存」と呼んでいます。 確かに、 <code class="language-text">setCount(count + 1)</code> とエフェクト内に書いたので <code class="language-text">count</code> は依存配列内に必要な値です。ですが、 <code class="language-text">count + 1</code> に形成して React に送り返す事にしか <code class="language-text">count</code> を使っていません。しかし、 React は現在の <code class="language-text">count</code> の値をもう<em>知っています</em>。 <strong>今の値など関係なく、やることは React に state を increment するということを伝えるだけです。</strong></p>
<p><code class="language-text">setCount(c =&gt; c + 1)</code> はまさにそれをします。 React に state をどのように変更すべきか指示を送っていると考えてください。アップデートを<a href="/react-as-a-ui-runtime/#batching">バッチ処理したい</a>時など、他のケースでも関数型の更新は役に立ちます。</p>
<p><strong>我々は何も不正なことはしていません。実際に依存配列から抜き出すことができるように<em>実装した</em>だけです。我々のエフェクトはもう render scope 内の <code class="language-text">counter</code> の値を参照することはなくなりました：</strong></p>
<p><a href="/interval-right-f128ad20c28317ed27a3cb68197fc906.gif">動く interval の図</a></p>
<p><em>（依存配列の中の値が同じなので、エフェクトをスキップします。）</em></p>
<p>一度<a href="https://codesandbox.io/s/q3181xz1pj" target="_blank" rel="nofollow noopener noreferrer">試してみてください</a>。</p>
<p>エフェクトは一度しか実行されないのにも関わらず、初期 render に紐づいている interval の callback は <code class="language-text">c =&gt; c + 1</code> の指示を interval が発火する度に送ることが容易にできます。現在の <code class="language-text">counter</code> の state を知る必要がなくなったのです。なぜなら、 React がもう知っているから。</p>
<h2 id="関数アップデートと-google-docs"><a href="#%E9%96%A2%E6%95%B0%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88%E3%81%A8-google-docs" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>関数アップデートと Google Docs</h2>
<p>シンクロがエフェクトのメンタルモデルであると話したことを覚えていますか？シンクロの興味深い点として、システム感の情報伝達はなるべくそれぞれの状態と隔離されて行われるべきというのがあります。例えば、Google Docs でドキュメントを編集する際、<em>全て</em>のページをサーバーに送っているわけではありません。それは非効率であるからです。代わりに、ユーザーの動きを表したデータを送るのです。</p>
<p>我々のケースは少し違いますが、エフェクトの挙動はほぼ同じような原理です。<strong>必要最低限の情報をエフェクト内からコンポーネントに送ることが最適化の助けになります。</strong> <code class="language-text">setCount(c =&gt; c + 1)</code> のような関数アップデート型は、 <code class="language-text">setCount(count + 1)</code> のように不必要な state と紐づいていないので伝達する情報量は圧倒的に少ないのが分かります。アクションを表現しているだけです（増加）。必要最低限の state を見出すのは React 自体を理解するのに重要で、これはそれのアップデート版と言えるでしょう。</p>
<p>結果より<em>意図</em>を符号化する行為は、Google Docs が多人数編集を可能とした方法と似ています。少し言い過ぎかもしれませんが、関数アップデートも React の上では同じような挙動をしています。複数のソース（イベントハンドラやエフェクトのサブスクリプションなど）からのアップデートが確実にバッチ適用されて、かつ予測的であるのを保証してくれます。</p>
<p><strong>ですが、<code class="language-text">setCount(c =&gt; c + 1)</code> もそこまで効率的とは言えないです。</strong> できることが制限されているのと、少し不自然でもあります。例えば、変数が二つ定義されていてそれぞれがお互いの値に依存していたり、 <code class="language-text">prop</code> の値から次の <code class="language-text">state</code> を計算する必要がある場合はうまくいきません。ですが、幸いにも <code class="language-text">setCount(c =&gt; c + 1)</code> はもっとパワフルな代替手段があるのです。それが <code class="language-text">useReducer</code> です。</p>
<h2 id="アクションからアップデートを分離する"><a href="#%E3%82%A2%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8B%E3%82%89%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88%E3%82%92%E5%88%86%E9%9B%A2%E3%81%99%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>アクションからアップデートを分離する</h2>
<p>先ほどの例を少し変えて、<code class="language-text">count</code> と <code class="language-text">step</code> の二つの <code class="language-text">state</code> 変数を持っていることにしましょう。 <code class="language-text">step</code> のインプットによって我々の <code class="language-text">interval</code> は <code class="language-text">count</code> の値を増やしていきます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>step<span class="token punctuation">,</span> setStep<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token function">setCount</span><span class="token punctuation">(</span>c <span class="token operator">=></span> c <span class="token operator">+</span> step<span class="token punctuation">)</span><span class="token punctuation">;</span></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text"></span>
<span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>step<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>e <span class="token operator">=></span> <span class="token function">setStep</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span>
<span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>(デモは<a href="https://codesandbox.io/s/zxn70rnkx" target="_blank" rel="nofollow noopener noreferrer">こちら</a>。)</p>
<p>私たちは<strong>何も不正なことはしていません。</strong> <code class="language-text">step</code> をエフェクト内で使い始めたため、依存配列の中に足しました。なので、このコードはちゃんと実行されます。</p>
<p>今の仕様のままだと、 <code class="language-text">step</code> は依存配列の中にあるので <code class="language-text">step</code> が変われば <code class="language-text">interval</code> はリスタートされてしまいます。そしてほとんどの場合、それは求めている挙動かもしれません。エフェクトをクリアして新しい <code class="language-text">interval</code> を立てるのは問題ありませんし、正当な理由なくそれを拒む必要はありません。</p>
<p>ですが、 <code class="language-text">step</code> が変わっても <code class="language-text">interval</code> の時間を止めたくないとしましょう。どうしたら <code class="language-text">step</code> を依存配列から取り除けるでしょうか？</p>
<p><strong>もし変数がもう一つの変数の現在値に依存してしまっている場合は、それらを <code class="language-text">useReducer</code> に置き換えた方がいいでしょう。</strong></p>
<p>もし <code class="language-text">setSomething(something =&gt; ...)</code> のような書き方をしているのであれば、 代わりに <code class="language-text">reducer</code> を使うことを考えた方がいいでしょう。 <code class="language-text">reducer</code> は<strong>コンポーネント内で起こったアクションとそのレスポンスに応じて state がアップデートされる関係性を分離してくれます。</strong></p>
<p>依存配列の中の <code class="language-text">step</code> を <code class="language-text">dispatch</code> に変えてみましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="gatsby-highlight-code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token keyword">const</span> <span class="token punctuation">{</span> count<span class="token punctuation">,</span> step <span class="token punctuation">}</span> <span class="token operator">=</span> state<span class="token punctuation">;</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'tick'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// etCount(c => c + step) の代わり;</span></span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dispatch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre></div>
<p>(デモは<a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="nofollow noopener noreferrer">こちら</a>。)</p>
<p>なぜこちらの方法が良いのか疑問に思われるでしょう。<strong>React は <code class="language-text">dispatch</code> 関数がコンポーネントライフタイムの間は常に constant であることを保証してくれます。なので、上記の例では interval に再サブスクライブする必要がありません。</strong></p>
<p>問題を解決しました！</p>
<p><em>（<code class="language-text">dispatch</code> 、 <code class="language-text">setState</code> や <code class="language-text">useRef</code> などのコンテナ変数は依存配列に入れる必要はありません。なぜかと言うと、 static であるということは React が保証しているからです。ですが入れることに関してはなんら問題はありません。）</em></p>
<p>エフェクト内で <code class="language-text">state</code> を読む代わりに、 <em>何が起こったか</em>の情報を含んだアクションを <code class="language-text">dispatch</code> します。こうすることによって、 <code class="language-text">step</code> 変数とエフェクトを分離させることができます。エフェクトはどのようにアップデートするかは興味を持たず、<em>何が起こったか</em>だけ教えてくれます。そして <code class="language-text">reducer</code> はそのロジックを一元化してくれます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  step<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> count<span class="token punctuation">,</span> step <span class="token punctuation">}</span> <span class="token operator">=</span> state<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'tick'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> count <span class="token operator">+</span> step<span class="token punctuation">,</span> step <span class="token punctuation">}</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'step'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token punctuation">,</span> step<span class="token punctuation">:</span> action<span class="token punctuation">.</span>step <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>(先ほどのデモを見過ごしてしまった場合は<a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="nofollow noopener noreferrer">こちらのデモをご覧ください。</a></p>
<h2 id="なぜ-usereducer-は-react-hooks-のチートモードなのか"><a href="#%E3%81%AA%E3%81%9C-usereducer-%E3%81%AF-react-hooks-%E3%81%AE%E3%83%81%E3%83%BC%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%AA%E3%81%AE%E3%81%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>なぜ <code class="language-text">useReducer</code> は React Hooks のチートモードなのか</h2>
<p><code class="language-text">state</code> のアップデートが一つ前や別の <code class="language-text">state</code> 変数に依存してる場合にエフェクトの依存配列から取り出す方法を学びました。 <strong>ですが、次の <code class="language-text">state</code> を計算するにあたって <code class="language-text">props</code> が必要な場合はどうでしょう？</strong> 例えば、APIが <code class="language-text">&lt;Counter step={1}&gt;</code> だとしましょう。この場合だと、 <code class="language-text">props.step</code> を依存配列に入れる以外の手段はないと思いますよね。</p>
<p>いえ、取り出す方法はあります！ <em><code class="language-text">reducer</code> 自体</em>をコンポーネント内に入れて <code class="language-text">props</code> を読むようにしたらいいのです：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="gatsby-highlight-code-line"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> step <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'tick'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> state <span class="token operator">+</span> step<span class="token punctuation">;</span></span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'tick'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dispatch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>このパターンは多少パフォーマンス最適化に影響を及ぼしますが、 <code class="language-text">reducer</code> 内で <code class="language-text">props</code> を参照することはできます。（デモは<a href="https://codesandbox.io/s/7ypm405o8q" target="_blank" rel="nofollow noopener noreferrer">こちら</a>。）</p>
<p><strong>この場合でも、 <code class="language-text">dispatch</code> は再 render されても不変であることは保証されています。</strong> なので、エフェクトの依存配列から取り除きたい場合は取り除くことが可能です。なぜかというと、エフェクトを再実行することはないからです。</p>
<p>どうして reducer は別の render に属している props を読むことができるの？と思われるでしょう。なぜかと言うと、 <code class="language-text">dispatch</code> をする時に React はそのアクションだけを覚えて、次の render 時に reducer を呼びます。その時には最新の props がスコープ内に存在しており、エフェクトの中かどうかというのは関係なくなります。</p>
<p><strong>これらの理由から私は <code class="language-text">useReducer</code> を React の<em>チートモード</em> と呼んでいます。アップデートロジックとそれらを宣言的に記述する表現を分離してくれます。こうすることによって、不必要な依存変数をエフェクトから取り除くことができ、必要最低限の render で済むのです。</strong></p>
<h2 id="エフェクト内に関数を入れる"><a href="#%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E5%86%85%E3%81%AB%E9%96%A2%E6%95%B0%E3%82%92%E5%85%A5%E3%82%8C%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>エフェクト内に関数を入れる</h2>
<p>関数は依存配列に入れる必要がないと思うのはよくある間違いです。例えば、この例はまともに動くように見えます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> hits<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span>
      <span class="token string">'https://hn.algolia.com/api/v1/search?query=react'</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// これでもいい？</span></span>
  <span class="token comment">// ...</span></code></pre></div>
<p><em>(<a href="https://codesandbox.io/s/8j4ykjyv0" target="_blank" rel="nofollow noopener noreferrer">この例</a> は Robin Wieruch の素晴らしい記事から抜粋しています — <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="nofollow noopener noreferrer">詳しくはこちら</a>!)</em></p>
<p>先に言っておくと、この例はちゃんと動きます。<strong>ですが、ローカル関数を依存配列に含めない一番の問題は、コンポーネントが肥大化していくと全てのケースをハンドリングしているか分からなくなるという点です。</strong></p>
<p>例えば、下記のコードのようにコードが分離されていて、さらにそれぞれの関数が五倍多いと想像して見てください：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// この関数がこれより多いと想像してください</span>
  <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query=react'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// この関数も、これより多いと想像してください</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>次に、どちらかの関数に <code class="language-text">state</code> か <code class="language-text">prop</code> を用いるとしましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// この関数がこれより多いと想像してください</span>
  <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span>  <span class="token punctuation">}</span>

  <span class="token comment">// この関数も、これより多いと想像してください</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>この場合、もし関数が呼ばれているエフェクトの依存配列の中身をアップデートし忘れると、エフェクトは <code class="language-text">prop</code> や <code class="language-text">state</code> からの変更をシンクロできません。それはよくないですね。</p>
<p>ですが、運よくこの問題には簡単な解決方法があります。 <strong>もしそれらの関数はエフェクト内でしか呼ばれていないのであれば、直接エフェクト内に移しましょう：</strong></p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token comment">// 関数定義をエフェクト内に移しました</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query=react'</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line"></span><span class="gatsby-highlight-code-line">    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列はオッケー</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>(<a href="https://codesandbox.io/s/04kp3jwwql" target="_blank" rel="nofollow noopener noreferrer">デモはこちら</a>.)</p>
<p>この方法を用いる利点はなんでしょうか？もう依存関係について関数をトラッキングする必要はありません。我々の依存配列は嘘をついていません： <strong>正真正銘、エフェクトはエフェクト外から何も用いてないからです。</strong></p>
<p>もし後ほど <code class="language-text">getFetchUrl</code> を編集して <code class="language-text">query</code> の <code class="language-text">state</code> を用いることがあれば、エフェクトの中で編集しているのに気づくでしょう - そして、 <code class="language-text">query</code> をエフェクトの依存配列に加える必要があるのもわかるはずです：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span>    <span class="token punctuation">}</span>

    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列はオッケー</span></span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>(デモは<a href="https://codesandbox.io/s/pwm32zx7z7" target="_blank" rel="nofollow noopener noreferrer">こちら</a>.)</p>
<p>依存関係を足すことによって、React をなだめるように書くだけではなく、クエリーが変わればデータを再取得するという一連の <em>理屈が通った</em> フローになります。 <strong><code class="language-text">useEffect</code> のデザインは、データフローの変更とそれに伴いエフェクトがどのようにシンクロするかを強制的に気づかせてくれます。ユーザーがバグを踏んでからやっと気付いたりする前に。</strong> </p>
<p><code class="language-text">eslint-plugin-react-hooks</code> プラグインの <code class="language-text">exhaustive-deps</code> lint ルールのおかげで、エディターに入力すると同時に<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="nofollow noopener noreferrer">エフェクトを分析して</a>どの依存関係が欠けているかチェックしてくれます。言い換えると、マシンがコンポーネントのどのデータフロー変更が正しくハンドリングされていないかチェックしてくれます。</p>
<p><img src="/exhaustive-deps-04a90dcbacb01105d634964880ebed19.gif" alt="lint ルールのgif"></p>
<p>素晴らしいですね。</p>
<h2 id="でも、この関数はエフェクト内に入れられない"><a href="#%E3%81%A7%E3%82%82%E3%80%81%E3%81%93%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E5%86%85%E3%81%AB%E5%85%A5%E3%82%8C%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>でも、この関数はエフェクト内に入れられない</h2>
<p>関数をエフェクト内に移せないことも時折起こるでしょう。例えば、複数のコンポーネント間のエフェクト内で同じ関数を呼んでおり、それをコピペしたくない時など。あるいは、関数自体が <code class="language-text">prop</code> として渡されたり。</p>
<p>これらの場合はエフェクトの依存関係を無視しても良いのでしょうか？僕は違うと思います。もう一度言いますが、<strong>エフェクトは依存関係について嘘をついてはいけません。</strong> スキップするより効率的な解決方法はあります。「関数は変わらない」とよく聞きますが、これは誤解です。この記事を読んでくれたらわかると思いますが、「関数が変わらない」ほど真実から遠い事実はありません。なぜなら、コンポーネント内に定義されている関数は毎 <code class="language-text">render</code> 時に変わるのですから。</p>
<p>ですが、それはそれで問題を引き起こします。例えば、二つのエフェクトが <code class="language-text">getFetchUrl</code> を呼ぶとしましょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 getFetchUrlが依存配列から抜けてる</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 getFetchUrlが依存配列から抜けてる</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>この場合、 <code class="language-text">getFetchUrl</code> をどちらかのエフェクト内に定義してしまうと、共通ロジックを使用できなくなるため入れたくないでしょう。</p>
<p>ですが、逆に依存関係に忠実だと、それはそれで問題を起こします。なぜかというと、両方のエフェクトは <code class="language-text">getFetchUrl</code> に依存してる（そして render ごとに違う）ので、我々の依存配列は全く役に立ちません：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token comment">// 🔴 render ごとに全てのエフェクトを再トリガーする</span></span><span class="gatsby-highlight-code-line">  <span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>getFetchUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚧 依存配列は合ってるが頻繁に変わる</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>getFetchUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚧 依存配列は合ってるが頻繁に変わる</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>簡単な解決方法として、 <code class="language-text">getFetchUrl</code> を依存配列から抜きたくなるでしょう。ですが、これはあまりお勧めできる解決策ではありません。抜いてしまうと、エフェクトでハンドリングされるべき変更が加わっても分かりづらいからです。このようなことが先ほどお見せした、インターバルが更新されないようなバグを引き起こすのです。</p>
<p>代わりとして、シンプルな二つの解決法があります。</p>
<p><strong>まず、もし関数がコンポーネントスコープから何一つ使用していないならば、関数をコンポーネント外にホイスティングして自由にエフェクト内で使う方法：</strong></p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="gatsby-highlight-code-line"><span class="token comment">// ✅ データフローに影響されない</span></span><span class="gatsby-highlight-code-line"><span class="token keyword">function</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">  <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line"><span class="token punctuation">}</span></span>
<span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列もオッケー</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列もオッケー</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>render スコープに関数がそもそもないので、データフローに影響されず依存配列に入れる必要もありません。間違って <code class="language-text">props</code> や <code class="language-text">state</code> に依存してしまう、ということも起きません。</p>
<p>もう一つの方法として、 <a href="https://ja.reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="nofollow noopener noreferrer"><code class="language-text">useCallback</code> フックを使用することもできます</a>:</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token comment">// ✅ 依存配列が同じだと関数の整合性が担保される</span></span><span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> getFetchUrl <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ✅ Callback deps are OK</span></span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>getFetchUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列もオッケー</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token string">'redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>getFetchUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列もオッケー</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">useCallback</code> が何をしてるかというと、依存チェックのレイヤーを追加しているのです。別の軸で問題を解決してるのです - <strong>関数の依存チェックを避けるのではなく、関数自体を依存関係に変更があったら時だけ変えているのです。</strong></p>
<p>なぜこのアプローチが有効的か見てみましょう。以前は、我々の例は二つの検索結果を表示してました（<code class="language-text">react</code> と <code class="language-text">redux</code> の検索クエリ）。ですが、任意のクエリを受け取るためインプットを追加するとしましょう。要するに、 <code class="language-text">query</code> を引数で受け取るのではなく、 <code class="language-text">getFetchUrl</code> はローカルの <code class="language-text">state</code> からクエリを受け取ります。</p>
<p><code class="language-text">query</code> の依存配列チェックがないことにすぐ気づけます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> getFetchUrl <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// クエリの引数がない</span>
    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 query が依存配列から抜けてる</span></span>  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">query</code> を依存配列に入れるよう <code class="language-text">useCallback</code> を修正すると、 <code class="language-text">getFetchUrl</code> が依存配列に含まれる全てのエフェクトは <code class="language-text">query</code> が変更した場合だけ再実行されます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SearchResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token comment">// ✅ 依存配列が同じだと関数の整合性が担保される</span></span><span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> getFetchUrl <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ✅ Callback deps are OK</span></span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">getFetchUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>getFetchUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列もオッケー</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">useCallback</code> のおかげで、 <code class="language-text">query</code> が同じであれば <code class="language-text">getFetchUrl</code> も同じであることが担保されるので、エフェクトは再実行されません。ですが <code class="language-text">query</code> が変わると <code class="language-text">getFetchUrl</code> も変わるのでデータを再取得しにいきます。エクセルのスプレッドシートでセルの中を変えると他のセルが自動的に再計算するイメージと似ています。</p>
<p>これらはデータフローとシンクロというマインドセットを掛け持った結果にすぎません。<strong>親コンポーネントから関数を渡す場合でも同じ解決方法が使えます：</strong></p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'react'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token comment">// ✅ 依存配列が同じだと関数の整合性が担保される</span></span><span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> fetchData <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token comment">// ... データをフェッチして返す</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ✅ Callback の依存配列はオッケー</span></span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">fetchData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>fetchData<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">{</span> fetchData <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>setData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchData<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依存配列はオッケー</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p> <code class="language-text">fetchData</code> は親コンポーネントの <code class="language-text">query</code> が変わるまで同じであることが担保されているので、子コンポーネントは必要になるまでデータを取得しにいきません。</p>
<h2 id="関数はデータフローの一部なのか"><a href="#%E9%96%A2%E6%95%B0%E3%81%AF%E3%83%87%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E3%81%AE%E4%B8%80%E9%83%A8%E3%81%AA%E3%81%AE%E3%81%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>関数はデータフローの一部なのか</h2>
<p> 興味深いのは、先ほど紹介したパターンはクラスの場合だとうまく動かなく、エフェクトとライフサイクルパラダイムの違いをはっきりと見せてくれます。この例をみてみてください：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    query<span class="token punctuation">:</span> <span class="token string">'react'</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token function-variable function">fetchData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>query<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token comment">// ... データをフェッチして何かする</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">fetchData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fetchData<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>今こう思うでしょう：「ねぇダン、<code class="language-text">useEffect</code> は <code class="language-text">componentDidMount</code> と <code class="language-text">componentDidUpdate</code> が一緒になっているだけなの知ってるから！これ以上ごまかしても無駄！」 <strong>ですがこれは <code class="language-text">componentDidUpdate</code> でも動きません：</strong></p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="gatsby-highlight-code-line">  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token comment">// 🔴 この比較は正にはならない</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>fetchData <span class="token operator">!==</span> prevProps<span class="token punctuation">.</span>fetchData<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">fetchData</code> はクラスメソッドなので、これは当たり前です（それかクラスプロパティー - どっちでもいいけど）。<code class="language-text">state</code> の変更があったからといって変わりません。なので、 <code class="language-text">this.props.fetchData</code> は <code class="language-text">prevProps.fetchData</code> と同じであるため再フェッチされません。なら、条件分岐を消したらどうでしょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre></div>
<p>ですが、こう記述すると <em>毎</em> render 時にフェッチしにいきます。（アニメーションをツリーの上に追加してあげると分かります。）ならば、特定のクエリに <code class="language-text">bind</code> するのはどうでしょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx">  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">fetchData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fetchData<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>query<span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre></div>
<p>ですが <code class="language-text">query</code> が変わってなくても <code class="language-text">this.props.fetchData !== prevProps.fetchData</code> は常に正です！なのでまだ <em>毎</em> render 時にフェッチしにいきます。</p>
<p>唯一の解決方法として、 <code class="language-text">query</code> 自体を子コンポーネントに渡すしかありません。子コンポーネントは <code class="language-text">query</code> を実際に使うことはないですが、変更を検知してフェッチを行うことができます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    query<span class="token punctuation">:</span> <span class="token string">'react'</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function-variable function">fetchData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://hn.algolia.com/api/v1/search?query='</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
    <span class="token comment">// ... データをフェッチして何かする</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">fetchData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fetchData<span class="token punctuation">}</span></span> <span class="token attr-name">query</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>query<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>query <span class="token operator">!==</span> prevProps<span class="token punctuation">.</span>query<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>React に関わって数年、もう不必要な <code class="language-text">props</code> を子に渡して親コンポーネントのエンキャプスレーションを壊す行為（そして数週間後になぜやる必要があったのかに気づく）に慣れてしまいました。</p>
<p><strong>クラスの場合、関数 props 自体はデータフローの一部ではありません。</strong> mutable な this の値が存在するので関数の整合性が担保できないからです。なので、関数だけ渡したくても無駄なデータを渡して diff をとる必要が出てくるのです。<code class="language-text">this.props.fetchData</code> がどの <code class="language-text">state</code> に依存していて、 <code class="language-text">state</code> がどのタイミングで変更されたを知る余地がありません。</p>
<p><strong><code class="language-text">useCallback</code> により、関数はデータフローに参加することができます。</strong> もし関数のインプットが変更されれば関数自体も変更されたと検知でき、インプットが変更されてなければ同じであることが分かります。<code class="language-text">useCallback</code> のおかげで、 <code class="language-text">props.fetchData</code> などの props の変更も、自動的に子へ伝わっていきます。</p>
<p><a href="https://ja.reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="nofollow noopener noreferrer"><code class="language-text">useMemo</code></a> も同じようなことを複雑なオブジェクトに適用してくれます：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">ColorPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 子の shallow equality check にちゃんと通ります</span>
  <span class="token comment">// color が変わらない限り</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>color<span class="token punctuation">,</span> setColor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'pink'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> style <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> color <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>color<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>style<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><strong><code class="language-text">useCallback</code> を巻き散らかすのはあまりよくないことを強調したいです。</strong> 良いエスケープハッチで、関数が子に渡されて子の中のエフェクトで呼ばれてる場合などではとても役に立ちます。それか子コンポーネントのメモ化を崩したくない時など。ですが、Hooks はそもそも <a href="https://ja.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="nofollow noopener noreferrer">関数を props として渡す行為をあまり推薦していません。</a> </p>
<p>上記の例の場合、個人的には <code class="language-text">fetchData</code> をエフェクト内に定義するか（そしてそれ自体をカスタムフックとして抽出できる）、トップレベルインポートにする方を好みます。エフェクトをシンプルに保ちたいのに、コールバックがあると複雑化してしまいます（例えば、 <code class="language-text">props.onComplete</code> のコールバックがリクエスト中に変わったりとか）。<a href="#swimming-against-the-tide">クラスでの振る舞い</a>は再現できますが、レースコンディションは解決されません。</p>
<h2 id="レースコンディションについて"><a href="#%E3%83%AC%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%B3%E3%83%87%E3%82%A3%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>レースコンディションについて</h2>
<p>典型的なデータフェッチングをするクラスコンポーネントは、これに似てるでしょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Article</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    article<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">async</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> article <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token constant">API</span><span class="token punctuation">.</span><span class="token function">fetchArticle</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> article <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>みなさんご存知の通り、このコードはバグを引き起こします。なぜなら、アップデートをハンドリングしていないから。なので、もう一つ典型的なクラスコンポーネントとして、次のような例をよく見るでしょう：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Article</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    article<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="gatsby-highlight-code-line">  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>id <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>  <span class="token keyword">async</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> article <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token constant">API</span><span class="token punctuation">.</span><span class="token function">fetchArticle</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> article <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>いいですね。ですが、まだバグを引き起こせます。なぜなら、リクエストの順番が担保されていないからです。例えば、 <code class="language-text">{id: 10}</code> をフェッチしていて <code class="language-text">{id: 20}</code> に変更してそのリクエストが先に返ってきた場合、最初にリクエストして後から終わった処理は <code class="language-text">state</code> を不正に上書きしてしまいます。</p>
<p>これがレースコンディションです。そして、これは <code class="language-text">async</code> / <code class="language-text">await</code> を含むコード（結果が戻るまで待つことが前提）とトップダウンなデータフロー（非同期関数の処理中に <code class="language-text">state</code> や <code class="language-text">props</code> が代わり得る）を混ぜたコードでよく起こる現象です。</p>
<p>エフェクトはこの問題を解決するものではありませんが、 非同期関数をエフェクトに渡そうとすると注意してくれます。（どのような問題に直面するかもっとはっきりさせるように注意文言を改善する必要がありますが。）</p>
<p>もし非同期処理がキャンセル可能ならば、cleanup 関数で非同期リクエストをキャンセルできるので、解決できますね。</p>
<p>あるいは、boolean を用いてトラッキングするというその場しのぎの解決方法もあります：</p>
<div class="gatsby-highlight" data-language="jsx"><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Article</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>article<span class="token punctuation">,</span> setArticle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">let</span> didCancel <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> article <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token constant">API</span><span class="token punctuation">.</span><span class="token function">fetchArticle</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>didCancel<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>        <span class="token function">setArticle</span><span class="token punctuation">(</span>article<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      didCancel <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>具体的にどのようにエラーハンドリングやローディングして、カスタムフックに抽出できるかに興味がある人はこちらの<a href="(https://www.robinwieruch.de/react-hooks-fetch-data/)">記事</a>を読むことをお勧めします。</p>
<h2 id="ハードルをあげる"><a href="#%E3%83%8F%E3%83%BC%E3%83%89%E3%83%AB%E3%82%92%E3%81%82%E3%81%92%E3%82%8B" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ハードルをあげる</h2>
<p>クラスのライフサイクルマインドセットだと、render で出力されるものと副作用は異なってみえます。UIのレンダリングは <code class="language-text">props</code> や <code class="language-text">state</code> ドリブンで引き起こされており整合性は取れているのは保証されてますが、副作用は違います。これがバグが起こる理由です。</p>
<p>ですが、 <code class="language-text">useEffect</code> のマインドセットだと、全てデフォルトでシンクロされています。副作用は React のデータフローの一部となります。<code class="language-text">useEffect</code> で起こる処理を上手くやれば、あなたのコンポーネントはエッジケースにより対応しやすくなります。</p>
<p>しかし、正確にするということは、より労力を費やす必要があります。これはかなり面倒です。シンクロを軸に置いて書くコードは、レンダリングとはシンクロしない一度限りの副作用の発火させるコードより難しいのは当たり前です。</p>
<p>もしあなたは <code class="language-text">useEffect</code> を主要ツールとして使用しているなら、少し心配です。ですが、 <code class="language-text">useEffect</code> は低レイヤーのブロックです。まだ Hooks が出て間もないので、特にチュートリアルなどでみんな低レイヤーであるものを乱用しています。時間が立つにつれ、コミュニティーは高レベルな Hooks に移っていくでしょう。</p>
<p>多種多様なアプリが、認証ロジックをカブセル化した <code class="language-text">useFetch</code> や theme context を使用する <code class="language-text">useTheme</code> などの Hooks を作成してるのを見てきました。これらのツールボックスが一度出来上がると、そこまで <code class="language-text">useEffect</code> を使用することは無くなってくるでしょう。ですが、 <code class="language-text">useEffect</code> がもたらす強靭性は、それらを上に作成される Hooks 全てが恩恵を受けられるでしょう。</p>
<p>これまでに、 <code class="language-text">useEffect</code> は主にデータフェッチング用として使われていました。ですが、データフェッチングは正確にはシンクロ問題ではありません。データフェッチング用の依存配列は主に <code class="language-text">[]</code> なので、より明確です。そもそも何をシンクロしているのでしょうか？</p>
<p>将来的に、<a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching" target="_blank" rel="nofollow noopener noreferrer">データフェッチング用の Suspense</a> が React にレンダリングを非同期処理中は中断するといったサポートをします。</p>
<p>Suspense が今後データフェッチングケースをハンドリングしていくにつれ、<code class="language-text">useEffect</code> は表舞台からフェードアウトして、本当に <code class="language-text">props</code> や <code class="language-text">state</code> を何かしらの副作用にシンクロしたい時だけに使われると思います。データフェッチングとは違い、このようなケースは自然に対応できます。なぜなら、そのために作られたからです。ですがSuspense がデータフェッチングケースをハンドリングするまでは、<a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="nofollow noopener noreferrer">これのような</a>カスタムフックを用いてデータフェッチングをすると良いでしょう。</p>
<h2 id="終わりに"><a href="#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB" aria-hidden class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>終わりに</h2>
<p>あなたはもう私が知ってるエフェクトの全てを知ってるはずなので、一度最初の<a href="#tldr">TLDR</a>に戻ってみてください。ちゃんと伝わりますでしょうか？抜け漏れとかないですか？</p>
<p>ツイッターで意見聞きたいです！読んでいただきありがとうございました。</p></div><footer><p><a href="https://mobile.twitter.com/search?q=https%3A%2F%2Foverreacted.io%2Fa-complete-guide-to-useeffect%2F" target="_blank" rel="noopener noreferrer">Discuss on Twitter</a> • <a href="https://github.com/gaearon/overreacted.io/edit/master/src/pages/a-complete-guide-to-useeffect/index.ja.md" target="_blank" rel="noopener noreferrer">Edit on GitHub</a></p></footer></article></main><aside><div style="margin:90px 0 40px 0;font-family:system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;,
    &quot;Roboto&quot;, &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;, &quot;Fira Sans&quot;,
    &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif"><form action="https://app.convertkit.com/forms/812047/subscriptions" class="seva-form formkit-form" method="post" min-width="400 500 600 700 800" style="background-color:rgb(255, 255, 255);border-radius:6px"><div data-style="full"><div data-element="column" class="formkit-column" style="background-color:rgb(249, 250, 251)"><h1 class="formkit-header" data-element="header" style="color:rgb(77, 77, 77);font-size:20px;font-weight:700">Join the Newsletter</h1><div data-element="subheader" class="formkit-subheader" style="color:rgb(104, 104, 104)"><p>Subscribe to get my latest content by email.</p></div><div class="formkit-image"><svg xmlns="http://www.w3.org/2000/svg" width="46" height="46" viewBox="0 0 46 46" style="max-width:100%"><g fill="none" fill-rule="evenodd"><path fill="#DD92AB" d="M23,36 C22.813,36 22.627,35.948 22.463,35.844 L0.463,21.844 C0.159,21.651 -0.017,21.308 0.001,20.948 C0.02,20.589 0.23,20.266 0.553,20.105 L23,6 L45.447,20.105 C45.769,20.266 45.98,20.588 45.999,20.948 C46.018,21.308 45.841,21.65 45.537,21.844 L23.537,35.844 C23.373,35.948 23.187,36 23,36 Z"></path><path fill="#FFF" d="M38,37 L8,37 L8,1 C8,0.448 8.448,0 9,0 L37,0 C37.552,0 38,0.448 38,1 L38,37 Z"></path><path fill="#FFA7C4" d="M45,46 C44.916,46 44.831,45.989 44.748,45.968 L21.748,39.968 L22,33 L46,21 L46,45 C46,45.31 45.856,45.602 45.611,45.792 C45.435,45.928 45.219,46 45,46 Z"></path><path fill="#FFC3D7" d="M45,46 L1,46 C0.447,46 0,45.552 0,45 L0,21 L45.479,44.122 C45.88,44.341 46.083,44.804 45.969,45.247 C45.856,45.69 45.457,46 45,46 Z"></path><path fill="#FFA7C4" d="M19 20.414L14.293 15.707C13.902 15.316 13.902 14.684 14.293 14.293L19 9.586 20.414 11 16.414 15 20.414 19 19 20.414zM27 20.414L25.586 19 29.586 15 25.586 11 27 9.586 31.707 14.293C32.098 14.684 32.098 15.316 31.707 15.707L27 20.414z"></path></g></svg></div></div><div data-element="column" class="formkit-column"><ul class="formkit-alert formkit-alert-error" data-element="errors" data-group="alert"></ul><div data-element="fields" class="seva-fields formkit-fields"><div class="formkit-field"><input type="text" class="formkit-input" aria-label="Your first name" name="fields[first_name]" placeholder="Your first name" style="border-color:rgb(227, 227, 227);border-radius:4px;color:rgb(0, 0, 0);font-weight:400"/></div><div class="formkit-field"><input type="email" class="formkit-input" name="email_address" aria-label="Your email address" placeholder="Your email address" style="border-color:rgb(227, 227, 227);border-radius:4px;color:rgb(0, 0, 0);font-weight:400"/></div><button data-element="submit" class="formkit-submit formkit-submit" style="background-color:hsl(340, 63%, 55%);border-radius:24px;color:white;font-weight:700"><div class="formkit-spinner"></div><span>Subscribe</span></button></div><div data-element="guarantee" class="formkit-guarantee" style="color:rgb(77, 77, 77);font-size:13px;font-weight:400"><p>I won’t send you spam.</p><p>Unsubscribe at <em>any</em> time.</p></div></div></div></form></div><h3 style="font-family:Montserrat, sans-serif;margin-top:0.4375rem"><a style="box-shadow:none;text-decoration:none;color:var(--pink)" href="/">Overreacted</a></h3><div style="display:flex;margin-bottom:3.5rem"><img src="/static/profile-pic-69c77131fd248a7aaaf26fab021f469f.png" alt="Yusuf Unlu" style="margin-right:0.875rem;margin-bottom:0;height:3.5rem;border-radius:50%"/><p style="max-width:310px">Personal blog by <a href="https://mobile.twitter.com/yufusunlu">Yusuf Unlu</a>.<!-- --> <!-- -->I explain with words and code.</p></div><nav><ul style="display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:0"><li></li><li></li></ul></nav></aside></div></div></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-130227707-1', 'auto', {});
      
      
      
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-blog-post-js","jsonName":"ja-a-complete-guide-to-useeffect-ae9","path":"/ja/a-complete-guide-to-useeffect/"};window.dataPath="472/path---ja-a-complete-guide-to-useeffect-ae-9-e23-LvXwMLbvzwf7aFMogprKT2cg6dg";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-83825dcbe188439d174e.js"],"component---src-templates-blog-index-js":["/component---src-templates-blog-index-js-1d061c91bf8b4d1ed13d.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js.f3aea2f29a9b96501823.css","/component---src-templates-blog-post-js-5ff9d93420b5b2cefece.js"],"component---src-pages-404-js":["/component---src-pages-404-js.e9c5c3b80c5e9b8c6fa0.css","/component---src-pages-404-js-6115a896c1bd484b3973.js"],"component---src-pages-confirm-js":["/component---src-pages-confirm-js.e9c5c3b80c5e9b8c6fa0.css","/component---src-pages-confirm-js-e5c8bcda280c240e1d6e.js"],"component---src-pages-thanks-js":["/component---src-pages-thanks-js.e9c5c3b80c5e9b8c6fa0.css","/component---src-pages-thanks-js-bd098f6660863fbb8af2.js"],"pages-manifest":["/pages-manifest-f3e11a74ebf6959e04be.js"]};/*]]>*/</script><script src="/webpack-runtime-dea655677e505366ecd7.js" async=""></script><script src="/1-1b550cd61a5e170131aa.js" async=""></script><script src="/2-31a6021f1637c5720eda.js" async=""></script><script src="/0-b197e8c6c7ff26484233.js" async=""></script><script src="/app-83825dcbe188439d174e.js" async=""></script><script src="/component---src-templates-blog-post-js-5ff9d93420b5b2cefece.js" async=""></script></body></html>